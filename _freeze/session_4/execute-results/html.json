{
  "hash": "cfdde5805819ff56f39797ece59b0a6d",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters:\n  - naquiz\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-title: \"In this session:\"\n---\n\n\n\n\n# Session 4: Putting it all together\n\nIn this session we will combine all the skills we have learned so far to perform a complete analysis of a small dataset.\n\n::: {.callout-tip title=\"Learning Objectives\"}\nAt the end of this session, learners should be able to:\n\n1.  Describe the key steps in data analysis (exploration, manipulating and plotting)\n\n2.  Understand how pivot and join functions can be used to reshape and combine entire data frames\n:::\n\n## Introduction to the dataset\n\nIn this session we will use the `mousezempic_dosage_data` and `mousezempic_expression_data` data frames, which contain information about the mice and their gene expression levels, respectively.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir.create(\"data\") # create data directory if it doesn't exist\ndownload.file(\"https://raw.githubusercontent.com/kzeglinski/new_wehi_r_course/refs/heads/main/data/mousezempic_expression_data.tsv\", \"data/mousezempic_expression_data.tsv\") # download data\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# read in dosage data\nmousezempic_dosage_data <- read_csv(\"data/mousezempic_dosage_data.csv\")\nmousezempic_dosage_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in expression data\nmousezempic_expression_data <- read_tsv(\"data/mousezempic_expression_data.tsv\")\nmousezempic_expression_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 453 × 11\n   id_num Th_rep1 Th_rep2 Th_rep3 Prlh_rep1 Prlh_rep2 Prlh_rep3 Hprt1_rep1\n    <dbl>   <dbl>   <dbl>   <dbl>     <dbl>     <dbl>     <dbl>      <dbl>\n 1      1   1431.   2737.   2036.      297.      428.      320.       741.\n 2      2   2699.   4180.   3860.      388.      680.      500.       843.\n 3      3   3596.   5194.   4128.      201.      346.      266.      1047.\n 4      4   2723.   4442.   3728.      317.      576.      478.       541.\n 5      5   2197.   3656.   2887.      114.      205.      173.       798.\n 6      6   2316.   3949.   3355.      242.      383.      305.       763.\n 7      7   1570.   2740.   2129.      294.      489.      427.       796.\n 8      8   2683.   4749.   3563.      231.      400.      309.       922.\n 9      9   3023.   5170.   3830.      289.      464.      390.       921.\n10     10   3254.   5980.   4250.      337.      583.      436.       740.\n# ℹ 443 more rows\n# ℹ 3 more variables: Hprt1_rep2 <dbl>, Hprt1_rep3 <dbl>, group <chr>\n```\n\n\n:::\n:::\n\n\n\n\n::: callout-note\nWe have used `read_csv()` for the mouse data and `read_tsv()` for the expression data. These are for reading data separated by commas and tab characters respectively. The `readr` package also provides `read_delim()` to let the package guess your delimiter, but if you know the format of your file then it's good practice to use the appropriate reading function for more predictable behaviour.\n:::\n\n::: callout-caution\nThere's nothing stopping someone from naming a file `file.csv` while having tab-separated data inside. This happens quite often in real-world data so it's a good idea to have a quick look at the data in an text editor before reading it in.\n:::\n\n## Tidy Data\n\nThe tidyverse revolves around an important concept called \"[tidy data](https://r4ds.hadley.nz/data-tidy.html)\". This is a specific representation of tabular data that is considered easy to work with. Tidy data is roughly defined as tabular data that contains:\n\n1.  Individual variables in columns\n2.  Individual observations in rows\n3.  One data value in each cell\n\nHaving individual variables in columns makes then accessible for performing tidyverse operations like `select()`, `mutate()`, `filter()` and `arrange()`. If variables were not stored as columns then these functions would not be able to access them by name.\n\nHaving individual observations in rows is important because it associates all variables of each observation with the same row. If the data from one observation is spread across multiple rows then it is easy to incorrect summaries from the `summarise()` function. When using the `filter()` function with tidy data, you can expect to keep all the data for an observation or none at all. When the data for observations is split over different rows, it's possible to unknowingly lose partial data from observations.\n\nHaving a single value in each cell makes it possible to perform meaningful computations for the values, for example you cannot take a `mean()` of a column of values that contain multiple different values.\n\nAlthough tidy data is the easiest to work with, it's often necessary to alter the format of your data for plotting or table displays. It's a good idea to keep your core data in a tidy format and treating plot or table outputs as representations of that tidy data.\n\n::: callout-note\nMost data you encounter will not be tidy, the first part of data analysis is usually called \"data-wranging\" and involves tidying up your data so it is easier to use for downstream analysis.\n:::\n\n## Reshaping and combining data {#sec-reshaping}\n\nThe `filter()`, `select()`, `mutate()` and `summarise()` functions we learned last session all operate along either the columns or the rows of data. Combining these operations cleverly can answer the majority of questions about your data. However, there are two useful families of functions: `pivot` for reshaping your data and `join` for combining your data from shared columns.\n\n### Reshaping data with pivot functions {#sec-pivot}\n\nPivoting is a way to change the shape of your tibble.\n\n- Pivoting longer reshapes the data to transfer data stored in columns into rows, resulting in more rows and fewer columns. \n\n- Pivoting wider is the reverse, moving data from rows into columns.\n\n![Pivot functions allow you to change the structure of your data frame](images/S02F10_pivot.png){width=\"50%\"}\n\nThe `pivot_longer()` function is used to pivot data from wide to long format, and the `pivot_wider()` function is used to pivot data from long to wide format.\n\n#### Pivot wider\n\nA common use case for `pivot_wider()` is to make a [contingency table](https://en.wikipedia.org/wiki/Contingency_table), which shows the number of observations for each combination of two variables. This is often easier to read than the same information in long format.\n\nFor example, let's say we want to create a table that shows how many mice there are of each strain, in each cage number. We can achieve this in a long format using `summarise()` as we learned in the previous section:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data %>%\n  summarise(\n    n_mice = n(),\n    .by = c(cage_number, mouse_strain))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  cage_number mouse_strain n_mice\n  <chr>       <chr>         <int>\n1 1A          CD-1             52\n2 3E          CD-1             44\n3 2B          CD-1             56\n4 3E          Black 6         124\n5 2B          BALB C           68\n```\n\n\n:::\n:::\n\n\n\n\nFor the specific task of counting, we can achieve the same effect using the `count()` tidyverse function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data %>%\n  count(cage_number, mouse_strain, name = \"n_mice\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  cage_number mouse_strain n_mice\n  <chr>       <chr>         <int>\n1 1A          CD-1             52\n2 2B          BALB C           68\n3 2B          CD-1             56\n4 3E          Black 6         124\n5 3E          CD-1             44\n```\n\n\n:::\n:::\n\n\n\n\nThis summarises by each combination of `cage_number` and `mouse_strain`, with the `n()` function giving the count of data belonging to that combination.\n\nTo get a contingency table, we wish to have the information in the `mouse_strain` column displayed along the column names and the values of `n_mice` becoming the values of the cells in the new table. Since the goal is to make the table wider, we use the `pivot_wider()` function. To achieve this, we instruct the `pivot_wider()` function to take names from the `mouse_strain` column and the values from the `n_mice` column.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data %>%\n  count(cage_number, mouse_strain, name = \"n_mice\") %>%\n  pivot_wider(names_from = mouse_strain, values_from = n_mice)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  cage_number `CD-1` `BALB C` `Black 6`\n  <chr>        <int>    <int>     <int>\n1 1A              52       NA        NA\n2 2B              56       68        NA\n3 3E              44       NA       124\n```\n\n\n:::\n:::\n\n\n\n\nThis has transformed our data into a contingency table, with `NA` where no data corresponding data exists for the specific `cage_number` and `mouse_strain` combination.\n\nWe can do the same thing to see how many of each mouse strains is in each of our experiment replicates.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data %>%\n  count(replicate, mouse_strain, name = \"n_mice\") %>%\n  pivot_wider(names_from = mouse_strain, values_from = n_mice)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  replicate `BALB C` `Black 6` `CD-1`\n  <chr>        <int>     <int>  <int>\n1 rep1            26        34     50\n2 rep2            18        46     50\n3 rep3            24        44     52\n```\n\n\n:::\n:::\n\n\n\n\n#### Pivot longer\n\nData can often arrive in the form similar to the contingency table we constructed. Although this data is easy to read, it is difficult to operate on using tidyverse functions because the `mouse_strain` data is now stored in the column names and not inside a column we can use as a variable. In order to make this kind of data tidy, we use the `pivot_longer()` function, which will create a pair of columns from the column names and the value of the corresponding cell.\n\nTo demonstrate `pivot_longer()`, we will use the `mousezempic_expression_data` that we downloaded earlier. This data frame contains the expression levels of two genes (TH and PRLH) suspected to be upregulated in mice taking MouseZempic, as well as one housekeeping gene (HPRT1), all measured in triplicate.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_expression_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 453 × 11\n   id_num Th_rep1 Th_rep2 Th_rep3 Prlh_rep1 Prlh_rep2 Prlh_rep3 Hprt1_rep1\n    <dbl>   <dbl>   <dbl>   <dbl>     <dbl>     <dbl>     <dbl>      <dbl>\n 1      1   1431.   2737.   2036.      297.      428.      320.       741.\n 2      2   2699.   4180.   3860.      388.      680.      500.       843.\n 3      3   3596.   5194.   4128.      201.      346.      266.      1047.\n 4      4   2723.   4442.   3728.      317.      576.      478.       541.\n 5      5   2197.   3656.   2887.      114.      205.      173.       798.\n 6      6   2316.   3949.   3355.      242.      383.      305.       763.\n 7      7   1570.   2740.   2129.      294.      489.      427.       796.\n 8      8   2683.   4749.   3563.      231.      400.      309.       922.\n 9      9   3023.   5170.   3830.      289.      464.      390.       921.\n10     10   3254.   5980.   4250.      337.      583.      436.       740.\n# ℹ 443 more rows\n# ℹ 3 more variables: Hprt1_rep2 <dbl>, Hprt1_rep3 <dbl>, group <chr>\n```\n\n\n:::\n:::\n\n\n\n\nThe data is currently in wide format, with each row representing a different mouse (identified by its `id_num`) and each column representing a different measurement of a gene. To reshape this data into a long format (where each measurement is contained on a separate row), we can use `pivot_longer()`, specifying three arguments:\n\n1.  `cols`: the columns to pivot from. You can use selection helpers like `contains()` or `starts_with()` to easily select multiple columns at once.\n2.  `names_to`: the name of a new column that will contain the original column names.\n3.  `values_to`: the name of a new column that will contain the values from the original columns.\n\nIn this particular case here's what the code would look like:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_expr_long <- mousezempic_expression_data %>%\n  pivot_longer(\n    cols = contains(\"_rep\"),\n    names_to = \"measurement\",\n    values_to = \"expression_level\"\n  )\n\nmousezempic_expr_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,077 × 4\n   id_num group     measurement expression_level\n    <dbl> <chr>     <chr>                  <dbl>\n 1      1 treatment Th_rep1                1431.\n 2      1 treatment Th_rep2                2737.\n 3      1 treatment Th_rep3                2036.\n 4      1 treatment Prlh_rep1               297.\n 5      1 treatment Prlh_rep2               428.\n 6      1 treatment Prlh_rep3               320.\n 7      1 treatment Hprt1_rep1              741.\n 8      1 treatment Hprt1_rep2             1300.\n 9      1 treatment Hprt1_rep3              988.\n10      2 treatment Th_rep1                2699.\n# ℹ 4,067 more rows\n```\n\n\n:::\n:::\n\n\n\n\nLet's go through those three arguments:\n\n1.  `cols = contains(\"_rep\")`: This tells R to pivot all columns that contain the string `\"_rep\"`. In this case, that's the columns `TH_rep1`, `TH_rep2`, `TH_rep3`, `PRLH_rep1`, `PRLH_rep2`, `PRLH_rep3`, `HPRT1_rep1`, `HPRT1_rep2`, and `HPRT1_rep3`.\n2.  `names_to = \"measurement\"`: This tells R to create a new column called 'measurement' that contains the names of the old columns. So, for example, the value of the 'measurement' column for the first row will be 'TH_rep1'.\n3.  `values_to = \"expression_level\"`: This tells R to create a new column called 'expression_level' that contains the values from the old columns. So, for example, the value of the 'expression_level' column for the first row will be the value of the `TH_rep1` column.\n\nAfter running this code, you'll see that the data frame is now in long format, with each row representing a different measurement of a gene for a different mouse.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mousezempic_expr_long, aes(x = measurement, y = expression_level, fill = group)) +\n  geom_col(position = \"dodge\") +\n  theme(legend.position = \"bottom\") +\n  labs(\n    fill = \"Group\",\n    x = \"Gene\",\n    y = \"Expression Level\"\n  ) +\n  scale_y_log10()\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-10-1.png){width=2000}\n:::\n:::\n\n\n\n\n::: {.callout-note title=\"Perplexed by pivoting?\"}\nPivoting can be a bit tricky to get your head around! Often when you're doing analysis, you'll run into the problem of knowing that you need to pivot, but not knowing exactly what arguments to use. In these cases, it can be helpful to look at examples online, [like those in the R for Data Science book](https://r4ds.hadley.nz/data-tidy.html#sec-pivoting).\n:::\n\n### Separating data in a column\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_expr_long %>%\n  separate(measurement, into = c(\"gene\", \"replicate\"), sep = \"_\") %>%\n  ggplot(aes(x = gene, y = expression_level, fill = group)) +\n  geom_col(position = \"dodge\") +\n  theme(legend.position = \"bottom\") +\n  labs(\n    fill = \"Group\",\n    x = \"Gene\",\n    y = \"Expression Level\"\n  )\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-11-1.png){width=2000}\n:::\n:::\n\n\n\n\n### Combining data with join functions {#sec-join}\n\nData analysis typically involves multiple tables of data. Often there will be tables that are contain related information that must be combined to answer the questions you're interested in. Tables that are related to each other tend to have one or more columns in common, and are referred to as \"relational data\". Combining relational data in useful ways requires the `join` family of functions. In general joins can accomplish two tasks\n\n-   Add new variables to an existing table containing additional information.\n-   Filter observations in one table based on whether or not they match observations in another table.\n-   Both of the above at the same time.\n\n![The left_join() function allows you to combine two data frames](images/S02F11_left_join.png)\n\nA common and basic join is the `left_join()`. It takes two data frame as arguments and optionally a vector of common columns to perform the join on. The reason it's called a left-join because it retains all rows from the left data frame while adding on columns from the right data frame only when the data in the designed joining column(s) match.\n\nFor example, we can join the `mousezempic_dosage_data` data frame with the `mousezempic_expression_data` data frame based on the `id_num` column, which is common to both data frames:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(mousezempic_dosage_data, mousezempic_expression_data, by = \"id_num\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 19\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 13 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>, Th_rep1 <dbl>, Th_rep2 <dbl>, Th_rep3 <dbl>, Prlh_rep1 <dbl>,\n#   Prlh_rep2 <dbl>, Prlh_rep3 <dbl>, Hprt1_rep1 <dbl>, Hprt1_rep2 <dbl>,\n#   Hprt1_rep3 <dbl>, group <chr>\n```\n\n\n:::\n:::\n\n\n\n\nThe `mousezempic_dosage_data` contains information about characteristics of each mouse, while the `mousempic_expression_data` contains the gene expressions of the mice. Each data frame has an `id_num` column that relates the data from the two data frames together, and we have joined them into one table that contains both the data about the mice as well as the expression of their genes.\n\nWith the `left_join()`, if there is a `id_num` value that exists in the right data frame but not found in the left, then that data will not be present in the joined table. For any `id_num` that appears only in the left but not the right data frame, the values in the newly created columns will be `NA`.\n\n::: callout-caution\nIf the values from the left data frame matches to multiple rows of the column in the right data frame, the `left_join()` will duplicate the data from the left data frame for each match to the right. This can cause issues with downstream summarisation if not carefully considered.\n:::\n\n#### Joining with mismatched column names\n\nOften the column containing the matching information has different names in different data frames. For example what might be called \"id_num\" in one data frame could also be called \"mouse_id\" in another data frame. In those cases the `by` argument of `left_join()` can be formatted to let the function know which column in the left data frame matches to which column on the right.\n\nWe will demonstrate this by renaming the `id_num` column in the `mousezempic_dosage_data` to `mouse_id` and using it to perform the join instead. We will use the `join_by(mouse_id == id_num)` helper function for the `by` argument to specify the different columns we wish to join by.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rename id_num to mouse_id\nmz_dosage_data_new <- mousezempic_dosage_data %>%\n  rename(mouse_id = id_num)\n\nmz_dosage_data_new\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   mouse_id <dbl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# perform left join by matching mouse_id of the left data frame to id_num of the right data frame\nmz_joined_data <- left_join(\n  mz_dosage_data_new, mousezempic_expression_data,\n  by = join_by(mouse_id == id_num)\n) %>%\n  drop_na() # keep only rows without NA\n\nmz_joined_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 19\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                   3.45 rep1      female     0.00193\n 5 CD-1         1A                   3.65 rep1      male       0.0019 \n 6 CD-1         1A                   3.62 rep1      female     0.00181\n 7 CD-1         1A                   4.68 rep1      male       0.00195\n 8 CD-1         1A                   3.2  rep1      female     0.00182\n 9 CD-1         1A                   3.8  rep1      male       0.00191\n10 CD-1         1A                   4.4  rep1      male       0.00198\n# ℹ 323 more rows\n# ℹ 13 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   mouse_id <dbl>, Th_rep1 <dbl>, Th_rep2 <dbl>, Th_rep3 <dbl>,\n#   Prlh_rep1 <dbl>, Prlh_rep2 <dbl>, Prlh_rep3 <dbl>, Hprt1_rep1 <dbl>,\n#   Hprt1_rep2 <dbl>, Hprt1_rep3 <dbl>, group <chr>\n```\n\n\n:::\n:::\n\n\n\n\n::: callout-note\nWhen joining data frames with mismatched column names, the column name from the left data frame argument will be retained for the joined result.\n:::\n\n::: callout-note\nAn older syntax exists for the `by` argument that would look like `by = c(\"mouse_id\" = \"id_num\")`. This does the same thing as what is shown above but the documentation now recommends the new syntax which allows for flexible options like joining to the closest.\n:::\n\n## Visualising the data\n\nThe first plot we will make is to visualise the relationship between the mousezempic drug dosage and the amount of weight loss.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmz_joined_data %>%\n  ggplot(aes(x = drug_dose_g, y = weight_lost_g)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-15-1.png){width=2000}\n:::\n:::\n\n\n\n\nWe see that there is a positive correlation between dosage and weight loss. Since we also have data about the mouse strain we can colour our plot using `mouse_strain` to observe if there's any particular effect.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmz_joined_data %>%\n  ggplot(aes(x = drug_dose_g, y = weight_lost_g, col = mouse_strain)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-16-1.png){width=2000}\n:::\n:::\n\n\n\n\nWe can also visualise the distribution of weight loss in each strain.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmz_joined_data %>%\n  ggplot(aes(x = mouse_strain, y = weight_lost_g, fill = mouse_strain)) +\n  geom_violin()\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-17-1.png){width=2000}\n:::\n:::\n\n\n\n\n### Accounting for confounding factors\n\nWe see that the Black 6 mice have higher weight loss, but two confounding factors come to mind: the Black 6 mice have higher drug doses, and may be larger to begin with. So first let's check if the Black 6 mice are indeed larger.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmz_joined_data %>%\n  ggplot(aes(x = mouse_strain, y = initial_weight_g, fill = mouse_strain)) +\n  geom_violin()\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-18-1.png){width=2000}\n:::\n:::\n\n\n\n\nWe see that the Black 6 mice had similar initial weight as the BALB mice, both of which tended to be heavier than the CD-1 mice. So we want to try to account for that by considering the relative change in weight, and additionally account for the relative change in weight per unit dosage. To do this we will need to create two new columns in our data frame.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmz_joined_data <- mz_joined_data %>%\n  mutate(\n    weight_loss_proportion = weight_lost_g / initial_weight_g,\n    weight_loss_proportion_per_dosage_g = weight_loss_proportion / drug_dose_g \n  )\n\nmz_joined_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 21\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                   3.45 rep1      female     0.00193\n 5 CD-1         1A                   3.65 rep1      male       0.0019 \n 6 CD-1         1A                   3.62 rep1      female     0.00181\n 7 CD-1         1A                   4.68 rep1      male       0.00195\n 8 CD-1         1A                   3.2  rep1      female     0.00182\n 9 CD-1         1A                   3.8  rep1      male       0.00191\n10 CD-1         1A                   4.4  rep1      male       0.00198\n# ℹ 323 more rows\n# ℹ 15 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   mouse_id <dbl>, Th_rep1 <dbl>, Th_rep2 <dbl>, Th_rep3 <dbl>,\n#   Prlh_rep1 <dbl>, Prlh_rep2 <dbl>, Prlh_rep3 <dbl>, Hprt1_rep1 <dbl>,\n#   Hprt1_rep2 <dbl>, Hprt1_rep3 <dbl>, group <chr>,\n#   weight_loss_proportion <dbl>, weight_loss_proportion_per_dosage_g <dbl>\n```\n\n\n:::\n:::\n\n\n\n\nWith that data we can assess whether or not the drug works more effectively on one strain than the other.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mz_joined_data, aes(x = mouse_strain, y = weight_loss_proportion_per_dosage_g)) +\n  geom_violin(aes(fill = mouse_strain))\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-20-1.png){width=2000}\n:::\n:::\n\n\n\n\nWe can further check if the results are consistent across replicates as well as between sexes by using faceting on `replicate` and `sex` as the rows and columns.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mz_joined_data, aes(x = mouse_strain, y = weight_loss_proportion_per_dosage_g)) +\n  geom_violin(aes(fill = mouse_strain)) +\n  facet_grid(rows = vars(replicate), cols = vars(sex))\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-21-1.png){width=2000}\n:::\n:::\n\n\n\n\nWith this we can feel reasonably confident that the doseage and initial weight adjusted weight loss is roughly equal in Black 6 and CD-1 mice while being lower in BALB/c mice. For the final presentation of such a result we might want to rescale the dosage to milligrams, change theme and label the axis more naturally.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmz_joined_data %>%\n  mutate(weight_loss_proportion_per_dosage_mg = weight_loss_proportion_per_dosage_g / 1000) %>%\n  mutate(\n    mouse_strain = case_when(\n      mouse_strain == \"Black 6\" ~ \"C57BL/6\",\n      mouse_strain == \"BALB C\" ~ \"BALB/c\",\n      mouse_strain == \"CD-1\" ~ \"CD-1\"\n    )\n  ) %>%\n  ggplot(aes(x = mouse_strain, y = weight_loss_proportion_per_dosage_mg)) +\n  geom_violin(aes(fill = mouse_strain)) +\n  scale_y_continuous(labels = scales::percent) +\n  labs(\n    x = \"Mouse Strain\",\n    y = \"Weight Loss per Mousezempic doseage (%/mg)\",\n    title = \"Dosage-adjusted percentage weight loss per strain\",\n    fill = \"Mouse Strain\"\n  ) +\n  theme_classic(base_size = 14)\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-22-1.png){width=2000}\n:::\n:::\n\n\n\n\n## Exploring gene expression\n\nAfter our analysis of the dosage and weight loss characteristics of the mice, we next want to have a look at their gene expression. The first thing we might want to see is the relationship between the mousezempic dosage and the Th gene. However we immediately see a problem as the Th gene expression is stored in 3 separate columns as a result of technical replicates.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmz_joined_data %>%\n  select(mouse_id, drug_dose_g, contains(\"Th_rep\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 5\n   mouse_id drug_dose_g Th_rep1 Th_rep2 Th_rep3\n      <dbl>       <dbl>   <dbl>   <dbl>   <dbl>\n 1        1     0.00181   1431.   2737.   2036.\n 2        2     0.00186   2699.   4180.   3860.\n 3        3     0.00195   3596.   5194.   4128.\n 4        5     0.00193   2197.   3656.   2887.\n 5        6     0.0019    2316.   3949.   3355.\n 6        7     0.00181   1570.   2740.   2129.\n 7        8     0.00195   2683.   4749.   3563.\n 8       13     0.00182    543.    910.    699.\n 9       14     0.00191   4263.   7349.   6320.\n10       15     0.00198   3079.   5890.   4685.\n# ℹ 323 more rows\n```\n\n\n:::\n:::\n\n\n\n\nTo make a scatter plot we're going to need all our gene expression values in a single column, given that we currently have the data in 3 columns, we will have to perform a `pivot_longer()` operation to reduce the number of columns while increasing the number of rows. The columns we wish to pivot longer are those corresponding to the repeated measurements of the Th gene and we want to store these column names in column named `measurement`.\n\nOnce the pivot has be performed, the `measurement` column will contains two values, that of the gene and the replicate. We can separate these values into individua columns using `separate()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pivot longer then separate measurement column into genes and replicate\nth_expr_data <- mz_joined_data %>%\n  select(mouse_id, drug_dose_g, contains(\"Th_rep\")) %>%\n  pivot_longer(cols = contains(\"Th_rep\"), names_to = \"measurement\", values_to = \"expression\") %>%\n  separate(measurement, into = c(\"gene\", \"replicate\"), sep = \"_\")\n\nth_expr_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 999 × 5\n   mouse_id drug_dose_g gene  replicate expression\n      <dbl>       <dbl> <chr> <chr>          <dbl>\n 1        1     0.00181 Th    rep1           1431.\n 2        1     0.00181 Th    rep2           2737.\n 3        1     0.00181 Th    rep3           2036.\n 4        2     0.00186 Th    rep1           2699.\n 5        2     0.00186 Th    rep2           4180.\n 6        2     0.00186 Th    rep3           3860.\n 7        3     0.00195 Th    rep1           3596.\n 8        3     0.00195 Th    rep2           5194.\n 9        3     0.00195 Th    rep3           4128.\n10        5     0.00193 Th    rep1           2197.\n# ℹ 989 more rows\n```\n\n\n:::\n:::\n\n\n\n\nSeeing how the technical replicates appear to have a wide value of measurements for each mouse, for the technical replicates we will combine their values using `summarise()` by `mouse_id` to take mean expression across the three replicates.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nth_expr_data %>%\n  summarise(\n    expression = mean(expression),\n    .by = c(drug_dose_g, mouse_id)\n  ) %>%\n  ggplot(aes(x = drug_dose_g, y = expression)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-25-1.png){width=2000}\n:::\n:::\n\n\n\n\n## Another case study - WHO tuberculosis data\n\nWe can look at another dataset containing tuberculosis (TB) cases broken down by year, country, age, gender, and diagnosis method. The data comes from the [2014 World Health Organization Global Tuberculosis Report](https://www.who.int/teams/global-tuberculosis-programme/data) and is typical of many real-life datasets in terms of structure. There are redundant columns, odd variable codes and missing values.\n\nWe want to tidy it up using the tools we have learned in order to try to extract some information from this data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,240 × 60\n   country  iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\n   <chr>    <chr> <chr> <dbl>       <dbl>        <dbl>        <dbl>        <dbl>\n 1 Afghani… AF    AFG    1980          NA           NA           NA           NA\n 2 Afghani… AF    AFG    1981          NA           NA           NA           NA\n 3 Afghani… AF    AFG    1982          NA           NA           NA           NA\n 4 Afghani… AF    AFG    1983          NA           NA           NA           NA\n 5 Afghani… AF    AFG    1984          NA           NA           NA           NA\n 6 Afghani… AF    AFG    1985          NA           NA           NA           NA\n 7 Afghani… AF    AFG    1986          NA           NA           NA           NA\n 8 Afghani… AF    AFG    1987          NA           NA           NA           NA\n 9 Afghani… AF    AFG    1988          NA           NA           NA           NA\n10 Afghani… AF    AFG    1989          NA           NA           NA           NA\n# ℹ 7,230 more rows\n# ℹ 52 more variables: new_sp_m4554 <dbl>, new_sp_m5564 <dbl>,\n#   new_sp_m65 <dbl>, new_sp_f014 <dbl>, new_sp_f1524 <dbl>,\n#   new_sp_f2534 <dbl>, new_sp_f3544 <dbl>, new_sp_f4554 <dbl>,\n#   new_sp_f5564 <dbl>, new_sp_f65 <dbl>, new_sn_m014 <dbl>,\n#   new_sn_m1524 <dbl>, new_sn_m2534 <dbl>, new_sn_m3544 <dbl>,\n#   new_sn_m4554 <dbl>, new_sn_m5564 <dbl>, new_sn_m65 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\nThe first thing we notice is that `country`, `iso2` and `iso3` all seem to be different encodings for the country. The `year` column is fine as a variable but the rest of the columns seem appear to be coding values in the column names. There are numeric values in the cells, and since we know this dataset is supposed to contain case numbers, and no column clearly denotes this, we suspect that the values in the columns are case numbers with the column names being descriptive of the cases.\n\nSince we believe that many of these column names are in fact encoding data, we want to `pivot_longer()` to put that information in a column for further processing.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pivot longer with columns 5 to 60, drop NA values\nwho_longer <- who %>%\n  pivot_longer(\n    cols = 5:60, # alternatively contains(\"_\")\n    names_to = \"description\",\n    values_to = \"cases\",\n    values_drop_na = TRUE\n  )\n\nwho_longer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76,046 × 6\n   country     iso2  iso3   year description  cases\n   <chr>       <chr> <chr> <dbl> <chr>        <dbl>\n 1 Afghanistan AF    AFG    1997 new_sp_m014      0\n 2 Afghanistan AF    AFG    1997 new_sp_m1524    10\n 3 Afghanistan AF    AFG    1997 new_sp_m2534     6\n 4 Afghanistan AF    AFG    1997 new_sp_m3544     3\n 5 Afghanistan AF    AFG    1997 new_sp_m4554     5\n 6 Afghanistan AF    AFG    1997 new_sp_m5564     2\n 7 Afghanistan AF    AFG    1997 new_sp_m65       0\n 8 Afghanistan AF    AFG    1997 new_sp_f014      5\n 9 Afghanistan AF    AFG    1997 new_sp_f1524    38\n10 Afghanistan AF    AFG    1997 new_sp_f2534    36\n# ℹ 76,036 more rows\n```\n\n\n:::\n:::\n\n\n\n\nIt doesn't look like the values in `description` are unique, so we can try to count them to get a sense of what we're dealing with. It will show us the unique values as well as the counts for each value.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_longer %>%\n  count(description)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 56 × 2\n   description      n\n   <chr>        <int>\n 1 new_ep_f014   1032\n 2 new_ep_f1524  1021\n 3 new_ep_f2534  1021\n 4 new_ep_f3544  1021\n 5 new_ep_f4554  1017\n 6 new_ep_f5564  1017\n 7 new_ep_f65    1014\n 8 new_ep_m014   1038\n 9 new_ep_m1524  1026\n10 new_ep_m2534  1020\n# ℹ 46 more rows\n```\n\n\n:::\n:::\n\n\n\n\nSome patterns emerge, and it maybe be possible to guess at exactly what these values mean. For example we see the presence of \"m\" and \"f\" in the encoding which probably encodes sex. Luckily we have a data dictionary ready from the source that tells us what this means.\n\n1.  The first part tells us if the data is new or old, in this case all data is new.\n2.  The next part describe the type of TB:\n\n-   `rel` for relapse\n-   `ep` for extrapulmonary\n-   `sn` for pulmonary TB that cannot be diagnosed with a pulmonary smear (smear negative)\n-   `sp` for pulmonary TB that can be diagnosed with a smear (smear positive)\n\n3.  The sex of the patient. Males and females denoted by `m` and `f` respectively.\n4.  The 7 age groups the data is divided into:\n\n-   `014`: 0 - 14 years old\n-   `1524`: 15 - 24 years old\n-   `2534`: 25 - 34 years old\n-   `3544`: 35 - 44 years old\n-   `4554`: 45 - 54 years old\n-   `5564`: 55 - 64 years old\n-   `65`: 65 or older\n\n### String manupulation\n\nArmed with that knowledge we can begin to tidy up our dataset! The first thing we will do is tidy up the `description` column, we will do this with some string manipulation functions from the tidyverse. These functions help us manipulate strings programatically and are essential in dealing with real-world data.\n\nSome useful functions for string manipulation include:\n\n- `str_replace(string, pattern, replacement)`: replaces the pattern in the string with the replacement.\n- `str_extract(string, pattern)`: extracts the part of the string matching the pattern.\n- `str_remove(string, pattern)`: removes the part of the string matching the pattern.\n\nThe full list of functions can be found in the [stringr package documentation](https://stringr.tidyverse.org/reference/index.html) and patterns can be written in very powerful ways with [regular expressions](https://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions). For our purposes we will just use simply fixed patterns.\n\nWe saw previously that we can use `separate()` to break apart on column into multiple columns. However, we see there is a problem in this dataset where the cases that are marked as relapse are encoded `newrel` which doesn't leave us with a separator to use. We can remedy this by using a combination of `mutate()` and `str_replace()` to replace all instances of `newrel` with `new_rel`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_longer <- who_longer %>%\n  mutate(description = str_replace(description, \"newrel\", \"new_rel\"))\n\nwho_longer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76,046 × 6\n   country     iso2  iso3   year description  cases\n   <chr>       <chr> <chr> <dbl> <chr>        <dbl>\n 1 Afghanistan AF    AFG    1997 new_sp_m014      0\n 2 Afghanistan AF    AFG    1997 new_sp_m1524    10\n 3 Afghanistan AF    AFG    1997 new_sp_m2534     6\n 4 Afghanistan AF    AFG    1997 new_sp_m3544     3\n 5 Afghanistan AF    AFG    1997 new_sp_m4554     5\n 6 Afghanistan AF    AFG    1997 new_sp_m5564     2\n 7 Afghanistan AF    AFG    1997 new_sp_m65       0\n 8 Afghanistan AF    AFG    1997 new_sp_f014      5\n 9 Afghanistan AF    AFG    1997 new_sp_f1524    38\n10 Afghanistan AF    AFG    1997 new_sp_f2534    36\n# ℹ 76,036 more rows\n```\n\n\n:::\n:::\n\n\n\n\nSince every single observation contains only new cases and no old cases, the `new_` portion of the encoding is redundant. So we can remove it using `str_remove()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_longer <- who_longer %>%\n  mutate(description = str_remove(description, \"new_\"))\n\nwho_longer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76,046 × 6\n   country     iso2  iso3   year description cases\n   <chr>       <chr> <chr> <dbl> <chr>       <dbl>\n 1 Afghanistan AF    AFG    1997 sp_m014         0\n 2 Afghanistan AF    AFG    1997 sp_m1524       10\n 3 Afghanistan AF    AFG    1997 sp_m2534        6\n 4 Afghanistan AF    AFG    1997 sp_m3544        3\n 5 Afghanistan AF    AFG    1997 sp_m4554        5\n 6 Afghanistan AF    AFG    1997 sp_m5564        2\n 7 Afghanistan AF    AFG    1997 sp_m65          0\n 8 Afghanistan AF    AFG    1997 sp_f014         5\n 9 Afghanistan AF    AFG    1997 sp_f1524       38\n10 Afghanistan AF    AFG    1997 sp_f2534       36\n# ℹ 76,036 more rows\n```\n\n\n:::\n:::\n\n\n\n\nNow one last problem remains, there is no separator between the sex and age group. So we can once again use `str_replace()` to edit in an underscore. Note that we use `\"_f\"` and `\"_m\"` as our patterns as a precaution in case the letters naturally occur elsewhere in the encoding.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_longer <- who_longer %>%\n  mutate(description = str_replace(description, \"_f\", \"_f_\")) %>%\n  mutate(description = str_replace(description, \"_m\", \"_m_\"))\n\nwho_longer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76,046 × 6\n   country     iso2  iso3   year description cases\n   <chr>       <chr> <chr> <dbl> <chr>       <dbl>\n 1 Afghanistan AF    AFG    1997 sp_m_014        0\n 2 Afghanistan AF    AFG    1997 sp_m_1524      10\n 3 Afghanistan AF    AFG    1997 sp_m_2534       6\n 4 Afghanistan AF    AFG    1997 sp_m_3544       3\n 5 Afghanistan AF    AFG    1997 sp_m_4554       5\n 6 Afghanistan AF    AFG    1997 sp_m_5564       2\n 7 Afghanistan AF    AFG    1997 sp_m_65         0\n 8 Afghanistan AF    AFG    1997 sp_f_014        5\n 9 Afghanistan AF    AFG    1997 sp_f_1524      38\n10 Afghanistan AF    AFG    1997 sp_f_2534      36\n# ℹ 76,036 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWith that we are finally able to separate the data into individual columns with `separate()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_separated <- who_longer %>%\n  separate(description, into = c(\"type\", \"sex\", \"age_group\"), sep = \"_\")\n\nwho_separated\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76,046 × 8\n   country     iso2  iso3   year type  sex   age_group cases\n   <chr>       <chr> <chr> <dbl> <chr> <chr> <chr>     <dbl>\n 1 Afghanistan AF    AFG    1997 sp    m     014           0\n 2 Afghanistan AF    AFG    1997 sp    m     1524         10\n 3 Afghanistan AF    AFG    1997 sp    m     2534          6\n 4 Afghanistan AF    AFG    1997 sp    m     3544          3\n 5 Afghanistan AF    AFG    1997 sp    m     4554          5\n 6 Afghanistan AF    AFG    1997 sp    m     5564          2\n 7 Afghanistan AF    AFG    1997 sp    m     65            0\n 8 Afghanistan AF    AFG    1997 sp    f     014           5\n 9 Afghanistan AF    AFG    1997 sp    f     1524         38\n10 Afghanistan AF    AFG    1997 sp    f     2534         36\n# ℹ 76,036 more rows\n```\n\n\n:::\n:::\n\n\n\n\nBecause the columns `iso2` and `iso3` contain redundant information about the country, we can remove them, but also retain them for reference as we may want to know what the short forms of the countries are when relating it other tables. To do so we can `select()` the columns containing this information, then use `distinct()` to keep only unique rows.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry_codes <- who_separated %>%\n  select(country, iso2, iso3) %>%\n  distinct()\n\ncountry_codes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 219 × 3\n   country             iso2  iso3 \n   <chr>               <chr> <chr>\n 1 Afghanistan         AF    AFG  \n 2 Albania             AL    ALB  \n 3 Algeria             DZ    DZA  \n 4 American Samoa      AS    ASM  \n 5 Andorra             AD    AND  \n 6 Angola              AO    AGO  \n 7 Anguilla            AI    AIA  \n 8 Antigua and Barbuda AG    ATG  \n 9 Argentina           AR    ARG  \n10 Armenia             AM    ARM  \n# ℹ 209 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWith that we can safely remove the redundant information from our data and end up with a tidy data frame.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_tidy <- who_separated %>%\n  select(-iso2, -iso3)\n\nwho_tidy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76,046 × 6\n   country      year type  sex   age_group cases\n   <chr>       <dbl> <chr> <chr> <chr>     <dbl>\n 1 Afghanistan  1997 sp    m     014           0\n 2 Afghanistan  1997 sp    m     1524         10\n 3 Afghanistan  1997 sp    m     2534          6\n 4 Afghanistan  1997 sp    m     3544          3\n 5 Afghanistan  1997 sp    m     4554          5\n 6 Afghanistan  1997 sp    m     5564          2\n 7 Afghanistan  1997 sp    m     65            0\n 8 Afghanistan  1997 sp    f     014           5\n 9 Afghanistan  1997 sp    f     1524         38\n10 Afghanistan  1997 sp    f     2534         36\n# ℹ 76,036 more rows\n```\n\n\n:::\n:::\n\n\n\n\nFrom there we can easily visualise various aspects of the data for analysis. For example we can see what country had the highest number of total cases in the year 2010.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_tidy %>%\n  filter(year == 2010) %>%\n  summarise(total_cases = sum(cases), .by = country) %>%\n  arrange(desc(total_cases))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 204 × 2\n   country                               total_cases\n   <chr>                                       <dbl>\n 1 China                                      869092\n 2 India                                      630164\n 3 South Africa                               364992\n 4 Indonesia                                  296272\n 5 Bangladesh                                 150856\n 6 Pakistan                                   124455\n 7 Russian Federation                         102823\n 8 Philippines                                 89198\n 9 Kenya                                       85484\n10 Democratic People's Republic of Korea       81240\n# ℹ 194 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWe can extract only the data from the top 10 countries based in 2010 cases and plot how their total case numbers between the years 2000 and 2010.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_10_countries <- who_tidy %>%\n  filter(year == 2010) %>%\n  summarise(total_cases = sum(cases), .by = country) %>%\n  arrange(desc(total_cases)) %>%\n  slice(1:10)\n\ntop_10_countries\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   country                               total_cases\n   <chr>                                       <dbl>\n 1 China                                      869092\n 2 India                                      630164\n 3 South Africa                               364992\n 4 Indonesia                                  296272\n 5 Bangladesh                                 150856\n 6 Pakistan                                   124455\n 7 Russian Federation                         102823\n 8 Philippines                                 89198\n 9 Kenya                                       85484\n10 Democratic People's Republic of Korea       81240\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwho_tidy %>%\n  filter(\n    country %in% top_10_countries$country,\n    year >= 2000,\n    year <= 2010\n  ) %>%\n  summarise(\n    total_cases = sum(cases), .by = c(country, year)\n  ) %>%\n  ggplot(aes(x = year, y = total_cases, col = country)) +\n  geom_point() +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](session_4_files/figure-html/unnamed-chunk-37-1.png){width=2000}\n:::\n:::\n\n\n\n\n\n<!-- :::::::::::::::::::: {.callout-important title=\"Practice exercises\"} -->\n<!-- Try these practice questions to test your understanding -->\n\n<!-- :::::::: question -->\n<!-- 1\\. What does the following code do? -->\n\n<!-- ```{r} -->\n<!-- #| eval: false -->\n<!-- mousezempic_dosage_data %>% -->\n<!--   summarise( -->\n<!--     med_tail = median(tail_length_mm, na.rm = TRUE), -->\n<!--     .by = c(mouse_strain, sex)) %>% -->\n<!--   pivot_wider(names_from = sex, values_from = med_tail) -->\n<!-- ``` -->\n\n<!-- ::::::: choices -->\n<!-- ::: choice -->\n<!-- Pivots data into a wide format where there is a column for each sex. -->\n<!-- ::: -->\n\n<!-- ::: {.choice .correct-choice} -->\n<!-- Calculates the median tail length for each unique combination of `mouse_strain` and `sex` in the `mousezempic_dosage_data` data frame, then pivots into a wide format where there is a column for each sex. -->\n<!-- ::: -->\n\n<!-- ::: choice -->\n<!-- Calculates the median tail length for each unique combination of `mouse_strain` and `sex` in the `mousezempic_dosage_data` data frame, then pivots into a wide format where there is a column for each mouse strain. -->\n<!-- ::: -->\n\n<!-- ::: choice -->\n<!-- It just gives an error -->\n<!-- ::: -->\n<!-- ::::::: -->\n<!-- :::::::: -->\n\n<!-- 2\\. I have run the following code to create a new column in the `mousezempic_dosage_data` data frame that gives the weight of the mice at the end of the experiment. -->\n\n<!-- ```{r} -->\n<!-- mousezempic_dosage_data %>% -->\n<!--   # add a column for the weight at the end of the experiment -->\n<!--   mutate(final_weight_g = initial_weight_g - weight_lost_g) %>% -->\n<!--   # select the relevant columns only -->\n<!--   select(id_num, initial_weight_g, final_weight_g) -->\n<!-- ``` -->\n\n<!-- Which pivot function call would I use to take this data from a wide format (where there is a column for the final and initial weight) to a long format (where there is a row for each mouse and each weight measurement)? -->\n\n<!-- ::::::: choices -->\n<!-- ::: choice -->\n<!-- `pivot_longer(cols = c(initial_weight_g, final_weight_g), names_to = \"weight\", values_to = \"timepoint\")` -->\n<!-- ::: -->\n\n<!-- ::: choice -->\n<!-- `pivot_longer(cols = c(id_num, final_weight_g), names_to = \"timepoint\", values_to = \"initial_weight_g\")` -->\n<!-- ::: -->\n\n<!-- ::: choice -->\n<!-- `pivot_wider(names_from = initial_weight_g, values_from = final_weight_g)` -->\n<!-- ::: -->\n\n<!-- ::: {.choice .correct-choice} -->\n<!-- `pivot_longer(cols = c(initial_weight_g, final_weight_g), names_to = \"timepoint\", values_to = \"weight\")` -->\n<!-- ::: -->\n<!-- ::::::: -->\n\n<!-- :::::::: question -->\n<!-- 3\\. Which of the following is NOT a valid way to join the `mousezempic_dosage_data` data frame with the `mousezempic_expression_data` data frame based on the `id_num` column? -->\n\n<!-- ::::::: choices -->\n<!-- ::: choice -->\n<!-- `mousezempic_dosage_data %>% left_join(mousezempic_expression_data, by = \"id_num\")` -->\n<!-- ::: -->\n\n<!-- ::: choice -->\n<!-- `left_join(mousezempic_dosage_data, mousezempic_expression_data, by = \"id_num\")` -->\n<!-- ::: -->\n\n<!-- ::: {.choice .correct-choice} -->\n<!-- `mousezempic_dosage_data %>% left_join(mousezempic_expression_data, .by = \"id_num\")` -->\n<!-- ::: -->\n\n<!-- ::: choice -->\n<!-- `mousezempic_dosage_data %>% left_join(mousezempic_expression_data, by = (\"id_num\" = \"id_num\"))` -->\n<!-- ::: -->\n<!-- ::::::: -->\n<!-- :::::::: -->\n\n<!-- <details> -->\n\n<!-- <summary>Solutions</summary> -->\n\n<!-- 1\\. The code first calculates the median tail length for each unique combination of `mouse_strain` and `sex` in the `mousezempic_dosage_data` data frame, then pivots the data into a wide format where there is a column for each sex in the dataset (because of the argument `names_from = sex` ) -->\n\n<!-- 2\\. The correct pivot function call to take the data from a wide format to a long format is `pivot_longer(cols = c(initial_weight_g, final_weight_g), names_to = \"timepoint\", values_to = \"weight\")`. This code tells R to pivot the `initial_weight_g` and `final_weight_g` columns into a long format, where there is a row for each mouse and each weight measurement. The `names_to` argument specifies to make a column called 'timepoint' that tells us whether the measurement is initial or final, and the `values_to` argument specifies the name of the new column that will contain these measurements. -->\n\n<!-- 3\\. The line of code that is NOT a valid way to join the `mousezempic_dosage_data` data frame with the `mousezempic_expression_data` data frame based on the `id_num` column is `mousezempic_dosage_data %>% left_join(mousezempic_expression_data, .by = \"id_num\")`. This line of code is incorrect because the `.by` argument is not used in the `left_join()` function (this can be confusing! it's `.by` when grouping by `by` when joining). The other options are valid ways to join the two data frames based on the `id_num` column: remember that we don't have to use pipes to join data frames, we can use the `left_join()` function directly, and we can use a named vector to specify the columns to join on (although here it's a bit redundant as the columns have the same name). -->\n\n<!-- </details> -->\n<!-- :::::::::::::::::::: -->\n\n<!-- summary - Reshaping data with `pivot_longer()` and `pivot_wider()` to change the structure of your data frame. -->\n\n<!-- -   Combining data with `left_join()` to merge two data frames based on a common column. -->\n\n<!-- questions etc -->\n\n<!-- 4.  Using the `mousezempic_dosage_data` data frame, write R code to: -->\n\n<!--     a.  Make a data frame that shows the number of mice of each strain, in each replicate. -->\n<!--     b.  Pivot this data frame into a wide format to create a contingency table. -->\n<!--     c.  Pivot the wide data frame from (b) back into a long format. -->\n\n<!-- 5.  Let's say I have two data frames, `df1` and `df2`, that I want to join based a shared 'key' column, that is called 'key' in `df1` and 'item_key' in `df2`. Write R code to join these two data frames using the `left_join()` function. -->\n\n<!-- solutions -->\n\n<!-- 4.  Here's how you could write R code to achieve the tasks: -->\n\n<!--     a.  `mousezempic_dosage_data %>% summarise(n_mice = n(), .by = c(mouse_strain, replicate))` -->\n<!--     b.  `mousezempic_dosage_data %>% summarise(n_mice = n(), .by = c(mouse_strain, replicate)) %>% pivot_wider(names_from = replicate, values_from = n_mice)` -->\n<!--     c.  `mousezempic_dosage_data %>% summarise(n_mice = n(), .by = c(mouse_strain, replicate)) %>% pivot_wider(names_from = replicate, values_from = n_mice) %>% pivot_longer(cols = starts_with(\"rep\"), names_to = \"replicate\", values_to = \"n_mice\")` -->\n\n<!-- 5.  To join the two data frames you could use `df1 %>% left_join(df2, by = c(\"key\" = \"item_key\"))` (with pipe) or `left_join(df1, df2, by = c(\"key\" = \"item_key\"))` (without pipe). -->\n",
    "supporting": [
      "session_4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}