{
  "hash": "dfb6ddfea9baa4b9a5ba367e2647a94c",
  "result": {
    "engine": "knitr",
    "markdown": "# Session 6: RNA-seq part 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(edgeR)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: limma\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(limma)\n\n# vector of file names\nfiles <- dir(path = \"data/counts\", pattern = \"GSM\")\ngroup <- factor(c(\"LP\", \"ML\", \"Basal\", \"Basal\", \n                  \"ML\", \"LP\", \"Basal\", \"ML\", \"LP\")) \nsamplenames <- c(\"10_6_5_11\", \"9_6_5_11\", \"purep53\", \"JMS8-2\", \"JMS8-3\",\n                 \"JMS8-4\", \"JMS8-5\", \"JMS9-P7c\", \"JMS9-P8c\")\n\n\n# create DGEList object\ndge <- readDGE(\n  files,\n  path = \"data/counts\",\n  columns = c(1, 3),\n  group = group,\n  labels = samplenames\n)\n\n# add gene annotation information\ndge$genes <- read.delim(\"data/Ses3_geneAnnot.tsv\", stringsAsFactors = FALSE)\n```\n:::\n\n\n## Linear modelling\n\nThe next step of the limma-voom analysis is to fit a linear model for each gene.\nA linear model is a broad class of statistical models that predict a variable of\ninterest using one or more 'explanatory' (also called 'predictor') variables. \nThe most basic type is linear regression, which models the relationship between\na continuous variable and continuous or categorical 'explanatory' variables. It\nuses an equation that looks like this: \n\n$Y = \\beta_{0} + \\beta_{1}X_{1} + \\beta_{2}X_{2}...$ \n\nThis equation is saying that a response variable of interest $Y$ is equal to a \nconstant ($\\beta_{0}$) plus the sum of the covariates ($X_{i}$) each multiplied\nby a constant coefficient ($\\beta_{i}$).\n\nOur experiment is quite simple, since there is only a single covariate, the\ncell type. The true benefit of using linear models is in its ability to \naccommodate more complex designs including multiple covariates.\n\nTo fit the linear models in the limma-voom framework we need two objects in\naddition to our data:\n\n* A design matrix, representing the covariates.\n* A contrast matrix, representing the specific comparison we wish to make.\n\n### Design matrix\n\nThe design matrix specifies the values of the covariates for each sample. This\nis represented as a matrix due to the mathematical convenience.\n\n\nTo generate a design matrix. We use the function `model.matrix()`, with the\nexpression `~0 + group`. This returns a matrix representing the design where\nthere is no intercept term and group is the only covariate. If we omit the\n`0` then there would be an intercept in the model, and if we included more\ncovariates then more columns would be generated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesign <- model.matrix(~0 + group, data = dge$samples)\ndesign\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          groupBasal groupLP groupML\n10_6_5_11          0       1       0\n9_6_5_11           0       0       1\npurep53            1       0       0\nJMS8-2             1       0       0\nJMS8-3             0       0       1\nJMS8-4             0       1       0\nJMS8-5             1       0       0\nJMS9-P7c           0       0       1\nJMS9-P8c           0       1       0\nattr(,\"assign\")\n[1] 1 1 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$group\n[1] \"contr.treatment\"\n```\n\n\n:::\n:::\n\n\nThere are 9 rows, one for each sample. Along the columns are the names of the\ngroups. The values in the cells denote membership of the particular sample\nfor a particular group, as our groups in this case are mutually exclusive,\neach row contains only a single 1 to denote membership in a single group.\n\n### Contrasts\n\n'Contrasts' let us ask specific questions between our experimental groups. In\nour data we have 3 experimental groups, if we are to test for differential\nexpression, we are most likely interested in differences between only two of the\ngroups at a time. Contrasts let us specify exactly what we're testing for, and\nis also represented by a matrix just like the design.\n\nA contrast matrix can be made using the `makeContrasts()` function. Within this\nfunction, we specify the name of each specific contrast and the formula for that\ncontrast. For example, the `BasalvsLP` contrasts compares the difference between\nthe `Basal` and `LP` groups. Note that the name of the phenotype groups must be\nwritten exactly as they are in the column names of our design matrix (see \nabove).\n\nIn addition to the individual contrasts, the function must know about the design\nof the model. This is passed through the `levels` argument, which either accepts\na matrix with the column names corresponding to levels of your experimental\ngroups, or the levels themselves as a character vector\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontr.matrix <- makeContrasts(\n  BasalvsLP = \"Basal - LP\",\n  BasalvsML = \"Basal - ML\",\n  LPvsML = \"LP - ML\",\n  levels = design) # alternatively 'levels = colnames(design)'\ncontr.matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Contrasts\nLevels  BasalvsLP BasalvsML LPvsML\n  Basal         1         1      0\n  LP           -1         0      1\n  ML            0        -1     -1\n```\n\n\n:::\n:::\n\n\nNote that the sum of all the numbers along each column is 0. The first column\nis the contrast for the difference between Basal (1) and LP (-1). This property\nis required for valid contrast matrices. An alternative test may be between\none group and the average of the others which would look like `c(1, -0.5, -0.5)`\ndown one of the columns.\n\n### Variance modelling with voom\n\nWe are now ready to fit our linear models. Limma fits linear models to the data\nwith the assumption that the underlying data is normally distributed. Count data\nis generally not normally distributed, but log transforming count data gives it\na roughly normal distribution sufficient for linear models to work well. To do\nthis, limma transforms the raw count data to log-cpm using library sizes\nand the normalisation factors we calculated previously.\n\nIn addition to the normalisation steps, the limma-voom pipeline uses the\n`voom()` function to generate weights for the individual genes based on a\nmodelled mean-variance relationship. This modelling allows use to get more\ninformation out of small sample sizes as the weights prevent our model from\nbeing more heavily influenced by more variable data points.\n\nThe `voom()` function takes as arguments, our `DGEList` object and our design\nmatrix. It also optionally outputs a plot of the mean-variance relationship of\nour data, called the 'voom-plot'. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- voom(dge, design, plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](session_6_files/figure-html/unnamed-chunk-5-1.png){width=2000}\n:::\n:::\n\n\nThe output of `voom()` (our variable `v`) is an `EList` object which contains\nthe following elements:\n\n* `genes` - a data frame of gene annotation data.\n* `targets` - data frame of sample data.\n* `E` - numeric matrix of normalised log-cpm values.\n* `weights` - numeric matrix of precision weights.\n* `design` - the design matrix.\n\n\n### Fitting the linear model\n\nWe are now ready to fit our linear model with `lmFit()`, which calculates\ncoefficients we defined in our design matrix `design`. The resulting object,\n`vfit` is a `MArrayLM` object. It contains a information about our genes (the\nsame data frame as `genes` from our `EList` object `v` above), the design matrix\nand a number of statistical outputs. Of most interest to us is the coefficients,\nstored in an element called `coefficients`. The first rows of this matrix is\nshown below. Each gene is row and is labelled using the EntrezID. Each column\ngives coefficients for each of our phenotype groups. These coefficients are\nweighted averages of the log-cpm of each gene in each group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvfit <- lmFit(v, design)\nhead(vfit$coefficients)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Basal        LP        ML\n497097     3.0677957 -4.578216 -3.854848\n100503874 -3.2300807 -6.118256 -6.305207\n100038431 -6.2389112 -6.118256 -6.305207\n19888     -6.7677975 -5.284107 -3.387890\n20671      0.3134058 -2.601497 -1.960416\n27395      4.3656951  3.792765  4.417114\n```\n\n\n:::\n:::\n\n\nWe can then use `contrasts.fit()` to calculate coefficients for each contrast\n(or 'comparison') we specified in our `contr.matrix`. The output is also an\nobject of the class `MArrayLM` (also known as an `MArrayLM` object). When we\ninspect the `coefficients` element now, we can see that each column is a\ncontrast that we specified in our contrast matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvfit <- contrasts.fit(vfit, contrasts = contr.matrix)\nhead(vfit$coefficients)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Contrasts\n             BasalvsLP   BasalvsML     LPvsML\n  497097     7.6460121  6.92264390 -0.7233682\n  100503874  2.8881750  3.07512580  0.1869508\n  100038431 -0.1206555  0.06629528  0.1869508\n  19888     -1.4836903 -3.37990752 -1.8962172\n  20671      2.9149031  2.27382208 -0.6410810\n  27395      0.5729302 -0.05141909 -0.6243493\n```\n\n\n:::\n:::\n\n\n## Statistical testing\n\nThe next step is to carry out statistical testing to determine which genes are\ndifferentially expressed. The function `eBayes()` computes moderated\nt-statistics, moderated F-statistics and log-odds of differential expression for\neach gene, given a fitted linear model. 'Moderated' refers to empirical Bayes\nmoderation, which borrows information across genes to obtain more accurate\nmeasures of variability for each gene. This also increases our power to detect\ndifferentially expressed genes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nefit <- eBayes(vfit)\n```\n:::\n\n\nWe can now look at the number of differentially expressed genes using the\n`decideTests()` function. The output of this function is a matrix where each\ncolumn is a contrast (comparison of interest) and each row is a gene. The\nnumbers 1, -1 and 0 mean up-regulated, down-regulated or not significantly\ndifferentially expressed, respectively. \n\nNote that `decideTests()` also accounts for multiple testing. The default method\nis Benjamini and Hochberg [@benjamini1995controlling] but several others are also\navailable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- decideTests(efit)\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTestResults matrix\n           Contrasts\n            BasalvsLP BasalvsML LPvsML\n  497097            1         1      0\n  100503874         1         1      0\n  100038431         0         0      0\n  19888             0        -1      0\n  20671             1         1      0\n27174 more rows ...\n```\n\n\n:::\n:::\n\n\nTo obtain the total number of differentially expressed genes for each\ncomparison, we can add the function `summary()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       BasalvsLP BasalvsML LPvsML\nDown        3877      5004   3472\nNotSig     17519     17182  22163\nUp          5783      4993   1544\n```\n\n\n:::\n:::\n\n\nThe function `topTable()` can be used to obtain more information on the\ndifferentially expressed genes for each contrast. `topTable()` takes as\narguments the `MArrayLM` object output by `eBayes()` (`efit`), the contrast name\nof interest and the number of top differentially expressed genes to output. Note\nthat the contrast name must be given in quotes and must be exactly as written in\nthe contrast matrix `contr.matrix`. \n\nIt outputs a data frame with the following information:\n\n* **Gene details** - gene information, from the `gene` element of the `MArrayLM`\nobject (`efit`).\n* `logFC` - the log2 fold change of the contrast.\n* `AveExpr` - the average log2 expression of that gene.\n* `t` - moderated t-statistic.\n* `P.Value` - p value.\n* `adj.P.Val` - adjusted p value.\n* `B` - log-odds that the gene is differentially expressed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop <- topTable(efit, coef = \"BasalvsLP\", n = Inf)\nhead(top)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      ENTREZID  SYMBOL TXCHROM     logFC   AveExpr         t      P.Value\n12759    12759     Clu   chr14 -5.177621  8.856284 -32.49244 6.107092e-14\n12521    12521    Cd82    chr2 -3.954595  7.069340 -31.24164 1.016658e-13\n16324    16324   Inhbb    chr1 -4.589997  6.460624 -29.97109 1.741973e-13\n53624    53624   Cldn7   chr11 -5.239579  6.295139 -28.23838 3.767208e-13\n26943    26943 Serinc3    chr2 -3.231408 10.189462 -27.41397 5.526704e-13\n14245    14245   Lpin1   chr12 -3.622175  6.293719 -27.53676 5.216399e-13\n         adj.P.Val        B\n12759 1.381587e-09 22.33748\n12521 1.381587e-09 21.77472\n16324 1.578169e-09 21.20649\n53624 1.630073e-09 20.41463\n26943 1.630073e-09 20.27957\n14245 1.630073e-09 20.26629\n```\n\n\n:::\n:::\n\n\nWith that we can complete our analysis by writing out some results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(top, file = \"BasalvsLP.csv\")\n```\n:::\n\n\n## MA Plot\n\nThe MA plot is a plot of log-fold-change (M-values) against log-expression\naverages (A-values), this is a common plot in RNA sequencing analysis to\nvisualise the result of differential expression tests. It can be created\nusing the `plotMA()` from the `limma` package. Creating this plot requires 3\npieces of information:\n\n* `object = efit`: The the fitted object containing the log-fold-change and log-expression\naverages\n* `coef = 1`: The column number of the contrast to plot since there are 3\ndifferent contrasts fitted within the object.\n* `status = dt[, 1]`: A vector of numerics denoting whether a gene is\nup-regulated or down-regulated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotMA(efit, coef = 1, status = dt[, \"BasalvsLP\"])\n```\n\n::: {.cell-output-display}\n![](session_6_files/figure-html/unnamed-chunk-13-1.png){width=2000}\n:::\n:::\n\n\nWe can also save this plot programmatically as a PDF for further editing. To do\nthis we use `pdf()` to turn on the pdf capture device, run the command that\ncreates the plot, which is now captured by the pdf, and then turn the device\noff.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npdf(file = \"BasalvsLP-MAPlot.pdf\")\nplotMA(efit, coef = 1, status = dt[, \"BasalvsLP\"])\ndev.off()\n```\n:::\n",
    "supporting": [
      "session_6_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}