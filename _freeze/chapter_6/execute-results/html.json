{
  "hash": "12f6a73983c7d6fbe5efa89908d54ff8",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters:\n  - naquiz\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-title: \"In this chapter:\"\nexecute:\n  error: true\n---\n\n\n\n\n\n# Chapter 6: RNA-seq part 2\n\nThe aim of this chapter is to complete the analysis of the RNA-seq data using the `limma` and `edgeR` packages. With the results of the analysis, we want to be able to produce publication quality figures and write out the results to a file for sharing or publication.\n\n::: {.callout-tip title=\"Learning Objectives\"}\n-   fit a linear model to the data\n-   construct design and contrast matrices for the linear model\n-   model the mean-variance relationship of the data using the `voom()` function\n-   perform statistical testing to identify differentially expressed genes\n-   visualise the results using an MA plot\n-   write out the results to a file\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load required packages\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(edgeR)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: limma\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(limma)\n\ngroup <- parse_factor(\n  c(\"LP\", \"ML\", \"Basal\", \"Basal\", \"ML\", \"LP\", \"Basal\", \"ML\", \"LP\"),\n  levels = c(\"Basal\", \"LP\", \"ML\")\n)\n\nsamplenames <- c(\n  \"10_6_5_11\", \"9_6_5_11\", \"purep53\", \"JMS8-2\", \"JMS8-3\",\n  \"JMS8-4\", \"JMS8-5\", \"JMS9-P7c\", \"JMS9-P8c\"\n)\n\n# create DGEList object\ndge <- readDGE(\n  dir(path = \"data/counts\", pattern = \"GSM*\"),\n  path = \"data/counts\",\n  columns = c(1, 3),\n  group = group,\n  labels = samplenames\n)\n\n# add gene annotation information\ndge$genes <- read_tsv(\"data/Ses3_geneAnnot.tsv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 27179 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): SYMBOL, TXCHROM\ndbl (1): ENTREZID\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# filter lowly expressed genes\nkeep <- filterByExpr(dge)\ndge <- dge[keep, ]\n\n# normalise the data for library size and RNA composition\ndge <- calcNormFactors(dge, method = \"TMM\")\n```\n:::\n\n\n\n\n\n## Linear modelling\n\nTo identify differentially expressed genes from our normalised gene expression data, we will use the `limma` package to fit linear models to the genes. A linear model is a broad class of statistical models that fit the value of an response (or dependent) variable as a linear function of one or more explanatory (or independent) variables (also called covariates).\n\nThe general form of a linear model looks like this:\n\n$Y = \\beta_{0} + \\beta_{1}X_{1} + \\beta_{2}X_{2}... + \\epsilon$\n\nThis equation is saying that a response variable of interest $Y$ is equal to a constant ($\\beta_{0}$) plus the sum of the covariates ($X_{i}$) each multiplied by a constant coefficient ($\\beta_{i}$) and some error term ($\\epsilon$). The error term is the difference between the observed value and the predicted value of the model and is assumed to have a normal distribution with mean 0 and some variance.\n\nOur experiment is quite simple, since there is only a single covariate, the cell type. The true benefit of using linear models is in its ability to accommodate more complex designs including multiple covariates.\n\nTo fit the linear models in the limma-voom framework we need two objects in addition to our data:\n\n-   A design matrix, representing the covariates.\n-   A contrast matrix, representing the specific comparison we wish to make.\n\n### Design matrix\n\nThe first step to fitting a linear model is to specify a design matrix. The design matrix specifies the values of the covariates for each sample, and is represented as a matrix due to the mathematical convenience.\n\nTo generate a design matrix. We use the function `model.matrix()`, with the expression `~0 + group`. This returns a matrix representing the design where there is no intercept term and group is the only covariate. If we omit the `0` then there would be an intercept in the model, and if we included more covariates then more columns would be generated.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesign <- model.matrix(~0 + group, data = dge$samples)\ndesign\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          groupBasal groupLP groupML\n10_6_5_11          0       1       0\n9_6_5_11           0       0       1\npurep53            1       0       0\nJMS8-2             1       0       0\nJMS8-3             0       0       1\nJMS8-4             0       1       0\nJMS8-5             1       0       0\nJMS9-P7c           0       0       1\nJMS9-P8c           0       1       0\nattr(,\"assign\")\n[1] 1 1 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$group\n[1] \"contr.treatment\"\n```\n\n\n:::\n:::\n\n\n\n\n\nThere are 9 rows, one for each sample. Along the columns are the names of the groups. The values in the cells denote membership of the particular sample for a particular group, as our groups in this case are mutually exclusive, each row contains only a single 1 to denote membership in a single group.\n\n### Contrasts\n\nContrast matrices are companions to design matrices. They are used to specify the comparison of interest. In our case, we have three experimental groups: `Basal`, `LP` and `ML`. So if we are to perform differential expression analysis, we are most likely interested in the differences between only two of the groups at a time. Contrast matrices let use specify which comparison we'd like to make, and are also represented as a matrix just like the design.\n\nA contrast matrix can be made using the `makeContrasts()` function. Within this function, we specify the name of each specific contrast and the formula for that contrast. For example, the `BasalvsLP` contrasts compares the difference between the `Basal` and `LP` groups. Note that the name of the phenotype groups must be written exactly as they are in the column names of our design matrix (see above).\n\nIn addition to the individual contrasts, the function must know about the design of the model. This is passed through the `levels` argument, which either accepts a matrix with the column names corresponding to levels of your experimental groups, or the levels themselves as a character vector. Here we first simplify the column names of our design matrix to make it easier to read. Then we create the contrast matrix using the `makeContrasts()` function.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(design) <- c(\"Basal\", \"LP\", \"ML\")\n\ncontr_matrix <- makeContrasts(\n  BasalvsLP = \"Basal - LP\",\n  BasalvsML = \"Basal - ML\",\n  LPvsML = \"LP - ML\",\n  levels = design # alternatively 'levels = colnames(design)'\n)\n\ncontr_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Contrasts\nLevels  BasalvsLP BasalvsML LPvsML\n  Basal         1         1      0\n  LP           -1         0      1\n  ML            0        -1     -1\n```\n\n\n:::\n:::\n\n\n\n\n\nThere are two things to note about a design matrix. First, the sum of the numbers in each column is equal to 0. Second, the way that you set up the equation in the matrix will determine the interpretation of the log-fold-change calculated later, as well as the meaning of up-regulated and down-regulated genes. For example, the contrast `Basal - LP` will give a positive log-fold-change for genes that are up-regulated in the `Basal` group compared to the `LP` group. If we had set up the contrast as `LP - Basal`, then the opposite would be true, and we would get a negative log-fold-change for genes that are up-regulated in the `Basal` group compared to the `LP` group.\n\n### Variance modelling with voom\n\nWe are now ready to fit our linear models. Limma fits linear models to the data with the assumption that the underlying data is normally distributed. Count data is generally not normally distributed, but log transforming count data gives it a roughly normal distribution sufficient for linear models to work well. To do this, limma transforms the raw count data to log-cpm using library sizes and the normalisation factors we calculated previously.\n\nIn addition to the normalisation steps, the limma-voom pipeline uses the `voom()` function to generate weights for the individual genes based on a modelled mean-variance relationship. This modelling allows us to get more information out of small sample sizes as the weights prevent our model from being more heavily influenced by more variable data points. The weights will then allow the linear model to be less influenced by genes with high variability, which is important for small sample sizes. The voom function also generates a mean-variance plot, which is useful for visualising the data.\n\nThe `voom()` function takes as arguments, our `DGEList` object and our design matrix. It also optionally outputs a plot of the mean-variance relationship of our data, called the 'voom plot'.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- voom(dge, design, plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-4-1.png){width=2000}\n:::\n:::\n\n\n\n\n\nThe output of `voom()` (our variable `v`) is an `EList` object which contains the following elements:\n\n-   `genes` - a data frame of gene annotation data.\n-   `targets` - data frame of sample data.\n-   `E` - numeric matrix of normalised log-cpm values.\n-   `weights` - numeric matrix of precision weights.\n-   `design` - the design matrix.\n\nThe 'voom plot' shows the mean-variance relationship of the data. The x-axis is the average log2 expression of each gene, and the y-axis is the log2 standard deviation of each gene. The idea is that the variance of a gene can be estimated as a function of its main expression, and that this estimate is more accurate than the direct calculation of the variance.\n\n### Fitting the linear model\n\nWe are now ready to fit our linear model with `lmFit()`, which calculates coefficients we defined in our design matrix `design`. The resulting object, `vfit` is a `MArrayLM` object. It contains a information about our genes (the same data frame as `genes` from our `EList` object `v` above), the design matrix and a number of statistical outputs. Of most interest to us is the coefficients, stored in an element called `coefficients`. The first rows of this matrix is shown below. Each gene is row and is labelled using the EntrezID. Each column gives coefficients for each of our phenotype groups. These coefficients are weighted averages of the log-cpm of each gene in each group.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvfit <- lmFit(v)\nhead(vfit$coefficients)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            Basal        LP        ML\n497097  3.0238407 -4.490714 -3.944753\n20671   0.2678024 -2.489068 -2.025190\n27395   4.3267906  3.900754  4.365115\n18777   5.2066347  4.975762  5.653810\n21399   5.2105491  4.901520  4.876117\n58175  -1.9300214  3.581004  3.133716\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can then use `contrasts.fit()` to calculate coefficients for each contrast (or 'comparison') we specified in our `contr_matrix`. The output is also an object of the class `MArrayLM` (also known as an `MArrayLM` object). When we inspect the `coefficients` element now, we can see that each column is a contrast that we specified in our contrast matrix.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvfit <- contrasts.fit(vfit, contrasts = contr_matrix)\nhead(vfit$coefficients)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Contrasts\n          BasalvsLP   BasalvsML      LPvsML\n  497097  7.5145551  6.96859344 -0.54596165\n  20671   2.7568708  2.29299235 -0.46387848\n  27395   0.4260362 -0.03832424 -0.46436046\n  18777   0.2308732 -0.44717502 -0.67804818\n  21399   0.3090295  0.33443212  0.02540261\n  58175  -5.5110259 -5.06373764  0.44728824\n```\n\n\n:::\n:::\n\n\n\n\n\nWith these values we essentially want to know whether or not the difference in values is significantly different from 0. If the difference is not significantly different from 0, then we have failed to establish a difference in the expression of a particularly gene between two groups. If the difference is significantly greater than 0, then we have up-regulation in the first group of the contrast, and if the difference is significantly less than 0, then we have down-regulation in the first group of the contrast.\n\n## Statistical testing\n\nTo actually test if the values are significantly different from 0, we use the `eBayes()` function to compute moderated t-statistics, moderated F-statistics and log-odds of differential expression for each gene, given a fitted linear model. 'Moderated' refers to empirical Bayes moderation, which borrows information across genes to obtain more accurate measures of variability for each gene. This also increases our power to detect differentially expressed genes.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nefit <- eBayes(vfit)\n```\n:::\n\n\n\n\n\nWe can now look at the number of differentially expressed genes using the `decideTests()` function. The output of this function is a matrix where each column is a contrast (comparison of interest) and each row is a gene. The numbers 1, -1 and 0 mean up-regulated, down-regulated or not significantly differentially expressed, respectively.\n\nNote that `decideTests()` also accounts for multiple testing. The default method is Benjamini and Hochberg [@benjamini1995] but several others are also available.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- decideTests(efit)\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTestResults matrix\n        Contrasts\n         BasalvsLP BasalvsML LPvsML\n  497097         1         1      0\n  20671          1         1      0\n  27395          0         0      0\n  18777          0        -1     -1\n  21399          0         1      0\n16619 more rows ...\n```\n\n\n:::\n:::\n\n\n\n\n\nTo obtain the total number of differentially expressed genes for each comparison, we can add the function `summary()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       BasalvsLP BasalvsML LPvsML\nDown        4501      4850   2701\nNotSig      7306      6996  11821\nUp          4817      4778   2102\n```\n\n\n:::\n:::\n\n\n\n\n\nThe function `topTable()` can be used to obtain more information on the differentially expressed genes for each contrast. `topTable()` takes as arguments the `MArrayLM` object output by `eBayes()` (`efit`), the contrast name of interest and the number of top differentially expressed genes to output. Note that the contrast name must be given in quotes and must be exactly as written in the contrast matrix `contr_matrix`.\n\nIt outputs a data frame with the following information:\n\n-   **Gene details** - gene information, from the `gene` element of the `MArrayLM` object (`efit`).\n-   `logFC` - the log2 fold change of the contrast.\n-   `AveExpr` - the average log2 expression of that gene.\n-   `t` - moderated t-statistic.\n-   `P.Value` - p value.\n-   `adj.P.Val` - adjusted p value.\n-   `B` - log-odds that the gene is differentially expressed.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop <- topTable(efit, coef = \"BasalvsLP\", n = Inf) |> as_tibble()\n\nhead(top)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 9\n  ENTREZID SYMBOL   TXCHROM logFC AveExpr     t  P.Value    adj.P.Val     B\n     <dbl> <chr>    <chr>   <dbl>   <dbl> <dbl>    <dbl>        <dbl> <dbl>\n1    12521 Cd82     chr2    -4.10    7.07 -35.5 3.38e-12 0.0000000466  18.4\n2    22249 Unc13b   chr4    -4.35    5.66 -32.4 8.66e-12 0.0000000466  17.4\n3    16324 Inhbb    chr1    -4.72    6.46 -30.8 1.45e-11 0.0000000466  17.1\n4    14245 Lpin1    chr12   -3.77    6.29 -30.0 1.93e-11 0.0000000466  16.9\n5   218518 Marveld2 chr13   -5.22    4.93 -30.9 1.42e-11 0.0000000466  16.8\n6    12759 Clu      chr14   -5.31    8.86 -29.6 2.22e-11 0.0000000466  16.7\n```\n\n\n:::\n:::\n\n\n\n\n\n## Volcano Plot\n\nSince we have the tibble of the data prepared, we can now create a volcano plot, which is very popular for RNA-seq analysis. The volcano plot is a scatter plot of the negative log10 p-value (y) against the log2 fold-change (x). This plot is useful for visualising the significance of the differentially expressed genes, as the more significant results are at the top left and right of the plot.\n\nFirst we will use `case_when()` to categorize the summary statistics for each gene with 'Up' 'Down' or 'Not DE', according to the adj.P.Val and logFC.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_cat <- top |> \n  mutate(status = case_when(adj.P.Val < 0.05 & logFC > 0 ~ 'Up',\n                            adj.P.Val < 0.05 & logFC < 0 ~ 'Down',\n                            .default='Non DE'))\n```\n:::\n\n\n\n\n\nNow to render the plot...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvolcano_plot <- top_cat %>%\n  ggplot(aes(x = logFC, y = -log10(P.Value), col = status)) +\n  geom_point(size=0.5) +\n  scale_colour_manual(values = c(\"blue\", \"#595959\", \"red\"))\n\n\nvolcano_plot\n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-12-1.png){width=2000}\n:::\n:::\n\n\n\n\n\nLastly we can label the gene names for the top-most DEGs by extracting the top 20 genes using `dplyr::slice()` and feeding them into `geom_label_repel()` from the ggrepel library. Here instead of rewriting code, we just keep adding geoms to the `volcano_plot` ggplot object created above!\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggrepel)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_de_genes <- top_cat |> group_by(status) |> arrange(P.Value) |> \n  slice_head(n = 10) |> \n  filter(status!='Non DE')\n\nvolcano_plot +\n  geom_label_repel(\n    data = top_de_genes,\n    aes(label = SYMBOL, col = status),\n    max.overlaps = 20,\n    show.legend = FALSE\n  ) \n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-14-1.png){width=2000}\n:::\n:::\n\n\n\n\n\n\n## Boxplots \n\nIt's important to create boxplots for a few differentially-expressed genes. This is a way of confirming that the results in our summary statistics tables and summary plots are valid, and that that our contrasts are set up correctly!\n\nBox plots require the gene expression data per sample, expressed as log(counts per million), or 'log(CPM)'.\n\nTo extract the logCPM to a tibble:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_logcpm <- cpm(dge, log = TRUE) |> as_tibble(rownames='ENTREZID')\n```\n:::\n\n\n\n\n\nIn this case we'll make boxplots from the log(CPM) values of individual samples, for the first 6 differentially-expressed genes in , which come from the BasalvsLP topTable `top_cat`. \nWe will extract the first 6 rows of the tibble using `slice`, then join the logCPM values per sample\n\n<!-- for this to render, yaml header updated to error: true -->\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_cat |> slice_head(n=6) |> \n  left_join(sample_logcpm,by='ENTREZID')\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `left_join()`:\n! Can't join `x$ENTREZID` with `y$ENTREZID` due to incompatible types.\nℹ `x$ENTREZID` is a <double>.\nℹ `y$ENTREZID` is a <character>.\n```\n\n\n:::\n:::\n\n\n\n\n\nGreat! An error! ... it seems that the ENTREZID column is not the same type between the `top_cat` and the `sample_logcpm` tibbles. We can fix this by changing the `top_cat$ENTREZID` into character data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_cat <- top_cat |> mutate(ENTREZID = as.character(ENTREZID))\n```\n:::\n\n\n\n\n\nNow we can rerun the `left_join()` and reshape the data to long form as required for ggplot2.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_gene_long <- top_cat |>\n  slice_head(n=6) |> \n  left_join(sample_logcpm, by='ENTREZID') |> \n  select(SYMBOL, '10_6_5_11' : 'JMS9-P8c') |> \n  pivot_longer(cols = -SYMBOL, names_to = 'sample', values_to = 'logCPM')\n```\n:::\n\n\n\n\n\nNext, we join the sample groupings to this reshaped data:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_group <- tibble('sample' = samplenames, \"group\" = group)\n\ntop_gene_long_samples <- left_join(top_gene_long, sample_group, by='sample')\n```\n:::\n\n\n\n\n\n...and plot the results\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplots <- top_gene_long_samples |> \n  ggplot(aes(x=group,y=logCPM, colour = group)) + \n  geom_boxplot() +\n  geom_jitter() +\n  facet_wrap(~SYMBOL, scales='free')\n\nboxplots\n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-20-1.png){width=2000}\n:::\n:::\n\n\n\n\n\n\n## Heatmap\n\nNext, we can create a heatmap of the differentially expressed genes. The heatmap is a useful way to visualise the expression of the differentially expressed genes in individual samples, especially when more than two conditions are being tested. We can use the `pheatmap` package to create the heatmap.\n\nFirst we need to install the package if you haven't already\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"pheatmap\")\n```\n:::\n\n\n\n\n\nThe data we will use for the heatmap is going to be the log2 cpm expression values of the top differentially expressed genes, within the `sample_logcpm` data extracted for the boxplots above. \nWe can use the `topTable()` function to get the top 50 differentially expressed genes for each contrast and combine them into a single data frame. \nFor more interpretable labels, we will use the gene symbols as the row names of the expression matrix.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_genes <- bind_rows(\n  topTable(efit, coef = \"BasalvsLP\", n = 50),\n  topTable(efit, coef = \"BasalvsML\", n = 50),\n  topTable(efit, coef = \"LPvsML\", n = 50)\n) %>%\n  select(ENTREZID, SYMBOL, TXCHROM) %>%\n  mutate(ENTREZID = as.character(ENTREZID)) |> \n  distinct() \n```\n:::\n\n\n\n\n\nWe now join the logCPM values for the top_genes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_genes_lcpm <- top_genes |> left_join(sample_logcpm)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(ENTREZID)`\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nTo create the heatmap we will use the `pheatmap()` function with the expression matrix. We will add in arguments to provide our own colour scale, to scale the data along the rows with a z-score, adding in sample annotation and clustering the data by rows and columns. We will also add in the option to show the row names and column names, and set the font size of the row names. You can experiment with removing each of these options to see how they affect the heatmap, as well as investigate additional options in the `pheatmap()` documentation.\n\nNote that pheatmap will complain if there are non-numeric columns in the input data, so here we deselect first three columns.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pheatmap)\n\nsample_anno <- dge$samples %>%\n  select(group)\n\nheatmap <- pheatmap(\n  top_genes_lcpm |> select(-c(1:3)),\n  color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(100),\n  scale = \"row\",\n  annotation_col = sample_anno,\n  border_color = NA,\n  cluster_rows = TRUE,\n  cluster_cols = TRUE,\n  show_rownames = TRUE,\n  show_colnames = TRUE,\n  fontsize_row = 6\n)\n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-24-1.png){width=2000}\n:::\n:::\n\n\n\n\n\n\n\n## Saving all the results\n\nNow that we have produced a series of plots and the top genes table, we can save these files to a directory. These figures may form the basis for publication figures, and the results table can partially presented as a result, or the full table can be included as a supplementary file.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir.create(\"output\")\n\nwrite_csv(top_cat, \"output/top_genes_BasalvsLP.csv\")\n\nggsave(\"output/volcano_plot_BasalvsLP.png\", volcano_plot)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSaving 10 x 5 in image\n```\n\n\n:::\n\n```{.r .cell-code}\nggsave(\"output/heatmap_BasalvsLP.png\", heatmap)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSaving 10 x 5 in image\n```\n\n\n:::\n\n```{.r .cell-code}\nggsave(\"output/boxplots.png\", boxplots)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSaving 10 x 5 in image\n```\n\n\n:::\n:::\n\n\n\n\n\nWith that we have come to the conclusion of the RNA-seq analysis and this course. You have now learned how to use various `tidyverse` packages to operate on data and create publication quality figures. You have also learned how to use the `limma` and `edgeR` packages to perform differential expression analysis on RNA-seq data. You should now be able to apply these skills to perform analysis on your own data.\n\n## References\n\n\n# Extension\n\n\n## MA Plot\n\nThe MA plot is a plot of log-fold-change (M-values) against log-expression averages (A-values), this is a common plot in RNA sequencing analysis to visualise the result of differential expression tests. It can be created using the `plotMA()` from the `limma` package. Creating this plot requires 3 pieces of information:\n\n-   `object = efit`: The the fitted object containing the log-fold-change and log-expression averages\n-   `coef = 1`: The column number of the contrast to plot since there are 3 different contrasts fitted within the object.\n-   `status = dt[, 1]`: A vector of numerics denoting whether a gene is up-regulated or down-regulated.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotMA(efit, coef = 1, status = dt[, \"BasalvsLP\"])\n\n#If you get an error with the above code, try:\nlimma::plotMA(efit, coef = 1, status = dt[, \"BasalvsLP\"])\n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-26-1.png){width=2000}\n:::\n:::\n\n\n\n\n\nAs before, we can try to re-create this plot using `ggplot2` to give us more flexibility in plotting. The information we'll need is in the `top_cat` tibble that we extracted for the volcano plot.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_cat %>%\n  ggplot(aes(x = AveExpr, y = logFC, col = status)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-27-1.png){width=2000}\n:::\n:::\n\n\n\n\n\nWhile the coordinates of the points are the same, there is still quite a bit of work to do to make this plot look like the one produced by `plotMA()`. First we have the fix up the colours of the points. We also have to make it such that the non-significant points are plotted below the other points. To do this we would need to make it so that the non-significant points are plotted first. We can do this by reordering the levels of the `status` factor so that the non-significant points are plotted first. Labels can also be added using `ggrepel` for the top 10 DE genes in each direction.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_cat_fct <- top_cat %>%\n  mutate(status=fct_relevel(status,'Up','Down','Non DE')) \n\nscale_cols <- c(\n  \"Not DE\" = \"#595959\",\n  \"Down\" = \"blue\",\n  \"Up\" = \"red\"\n)\n\nma_plot <- top_cat_fct %>%\n  mutate(status=fct_relevel(status,'Up','Down','Non DE')) |> \n  ggplot(aes(x = AveExpr, y = logFC, col = status)) +\n  geom_point(data = top_cat_fct %>% filter(status == \"Non DE\"), size = 0.1) +\n  geom_point(data = top_cat_fct %>% filter(status != \"Non DE\"), size = 1) +\n  geom_label_repel(\n    data = top_de_genes,\n    aes(label = SYMBOL, col = NULL),\n    max.overlaps = 20,\n    show.legend = FALSE\n  ) +\n  scale_colour_manual(values = scale_cols)\n\nma_plot\n```\n\n::: {.cell-output-display}\n![](chapter_6_files/figure-html/unnamed-chunk-28-1.png){width=2000}\n:::\n:::\n\n\n\n\n\nNow we can save the MA plot to our output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(\"output/volcano_plot_BasalvsLP.png\", volcano_plot)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSaving 10 x 5 in image\n```\n\n\n:::\n:::\n",
    "supporting": [
      "chapter_6_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}