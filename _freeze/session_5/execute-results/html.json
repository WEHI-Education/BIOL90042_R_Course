{
  "hash": "4d794842b20a16b3dbcc6c1653ff033b",
  "result": {
    "engine": "knitr",
    "markdown": "# Session 5: RNA-seq part 1\n\n\n\n\n\nIn this session we will run through the basic steps for analysing a simple\nRNA-seq experiment using the \n[limma-voom workflow](https://f1000research.com/articles/5-1408). This includes:\n\n* filtering out lowly expressed genes\n* normalisation\n* creating a multidimensional scaling (MDS) plot \n* creating a design matrix\n* fitting gene-wise linear models (with empirical Bayes moderation to more\naccurately estimate gene-wise variability) \n* performing statistical testing for differential expression\n\nThe aim of this session is to give you experience with a real-world RNA-seq\nanalysis, and making extensive use of an external library. We will not cover the\nstatistics in any depth. In general analysis packages will want your data in\nsome specific format, so it's important to be able to manipulate the data to fit\nthe package's requirements.\n\nMuch of the materials here are explained in greater detail in the limma user's\nguide. You can view this by typing `help(\"limma\")` and following the links.\n\n## DGEList\n\nThe data we are looking at comes from three cell populations (basal, luminal\nprogenitor (LP) and mature luminal (ML)) sorted from the mammary glands of\nfemale virgin mice, each profiled in triplicate.\n\nLet's start by creating our `DGEList` object. As a reminder, this object\ncontains 3 key pieces of data:\n\n* `counts`: the main data of this object, a matrix of count values with samples\nalong the columns and features/genes along the rows.\n* `samples`: a data frame containing annotation for the samples. The rows\nin this table describe the corresponding column of the counts data.\n* `genes`: a data frame containing annotation for the genes in the counts\nmatrix. The rows in this table describe the corresponding row in the counts\nmatrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load required packages\nlibrary(edgeR)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: limma\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(limma)\nlibrary(readr)\noptions(readr.show_col_types = FALSE)\n\n# vector of file names\nfiles <- dir(path = \"data/counts\", pattern = \"GSM\")\ngroup <- factor(c(\"LP\", \"ML\", \"Basal\", \"Basal\", \n                  \"ML\", \"LP\", \"Basal\", \"ML\", \"LP\")) \nsamplenames <- c(\"10_6_5_11\", \"9_6_5_11\", \"purep53\", \"JMS8-2\", \"JMS8-3\",\n                 \"JMS8-4\", \"JMS8-5\", \"JMS9-P7c\", \"JMS9-P8c\")\n\n\n# create DGEList object\ndge <- readDGE(\n  files,\n  path = \"data/counts\",\n  columns = c(1, 3),\n  group = group,\n  labels = samplenames\n)\n\n# add gene annotation information\ndge$genes <- read_delim(\"data/Ses3_geneAnnot.tsv\")\n```\n:::\n\n\nYou can index the DGEList object by treating it as if it were the counts matrix,\nthe object will handle the extraction and ordering of the sample and gene\nannotation data frames.\n\n## Filtering\n\nThe first step is to filter out lowly expressed genes. There are two main\nproblems with low abundant genes:\n\n* Technical variation is more problematic for low abundance genes. This\nvariation is thought to be due to two factors; insufficient mixing and \nlow sampling fraction [@mcintyre2011rna]. \n    * Insufficient mixing of solutions during library preparation can result \n    in uneven distribution of reads. \n    * RNA sequencing can be thought of as sampling. Measurement errors will\n    occur simply due to the random nature of the sampling process. This problem\n    affects lowly abundant RNA species more because the relative error for small\n    count values is larger than it would be for more highly abundant RNA\n    species.\n* Biologically, genes that are expressed at low, biologically not meaningful,\nlevels are not of interest.\n\nRemoving these highly variable, lowly expressed genes increases your 'power'\nto detect differentially expressed genes [@bourgon2010independent], where\n'power' is your ability to detect true positives. In testing for differential\nexpression, a statistical test is conducted for each gene. When a high number\nof statistical tests are performed, a portion of them will be significant\npurely due to random chance. A common procedure to control for the number of\nfalse positive is to perform 'multiple testing correction' on the p-values. This\nadjusts the p-value in a way that reduces the number of false positives but\ncomes at the cost of reduced power to detect true positives. If we filter out\nuninteresting, lowly expressed genes, we need to perform fewer statistical tests\nand reduce the impact that multiple testing adjustment has on detection power.\n\nThe `filterByExpr()` function provides an automatic way to filter genes.\n\nRoughly speaking, by default, it keeps genes with a count of 10 or more, in at\nleast as many samples as the smallest experimental group. In our experiment,\nthere are 3 phenotype groups each with 3 samples. Therefore we retain only genes\nthat have 10 or more counts in 3 or more samples.\n\nMore specifically, the actual filtering is done on counts per million, with\nsimilar result to the above criteria. This is to prevent bias against samples\nwith small library sizes.\n\nThe output of this function is a vector of logicals, indicating which genes\n(rows) should be kept and which filtered.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkeep <- filterByExpr(dge)\ntable(keep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nkeep\nFALSE  TRUE \n10555 16624 \n```\n\n\n:::\n\n```{.r .cell-code}\ndge <- dge[keep, , keep.lib.sizes = FALSE]\ndim(dge$counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16624     9\n```\n\n\n:::\n:::\n\n\nWe can see that we now have 16624 genes. We started with 27179 genes - meaning\nthat ~40% of genes have been filtered out.\n\n## Normalisation\n\nThe aim of normalisation is to remove systematic technical effects. There are\ntwo main factors that need to be normalised for in RNA-seq:\n\n* Sequencing depth/library size - technically, sequencing a sample to half the\ndepth will give, on average, half the number of reads mapping to each gene\n[@robinson2010scaling].\n* RNA composition - if a large number of genes are unique to, or highly\nexpressed in, only one experimental condition, the sequencing capacity available\nfor the remaining genes in that sample is decreased. For example, if there are\nonly five genes being studied in two experimental groups, if one gene is\nparticularly high in group A, then with limited sequencing depth, that gene\nwill reduce the counts of the remaining four genes. The effect of this is that\nthe remaining four genes appear under-expressed in group A compared to \ngroup B when the true amount of gene product is actually equal for these 4\ngenes [@robinson2010scaling]. \n\nSequencing depth is accounted for by calculating the counts per million (cpm).\nThis metric is calculated by:\n\n1. taking the library size (sum of all counts for a sample), \n2. dividing this by 1,000,000 to get the 'per million' scaling factor,\n3. then dividing all read counts for each gene in that sample by the\n'per million' scaling factor\n\nRNA composition can be accounted for by using more sophisticated normalisation\nmethodologies. We will use 'trimmed mean of M-values' (TMM), which estimates \nrelative RNA levels from RNA-seq data [@robinson2010scaling]. Under the\nassumption that most genes are not differentially expressed, TMM calculates a\nlibrary size scaling factor for each library (sample). This is done using the\nfollowing steps:\n\n1. calculate the gene expression log fold changes and absolute expression values\nfor pair-wise samples (selecting one sample from the experiment as a reference)\n2. remove the genes with the highest and lowest fold changes and absolute\nexpression values\n3. take a weighted mean of the remaining genes (where the weight is the inverse\nof the approximate asymptotic variances). This gives the normalisation factor\nfor each library (sample)\n\nSubsequent steps in this analysis will use log-cpm values, calculated using the\nnormalisation factors, which scales each library size.\n\nWe can calculate the normalisation factors, specifying that we want to use the\n`\"TMM\"` method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndge <- calcNormFactors(dge, method = \"TMM\")\n```\n:::\n\n\nThis function calculates the normalisation factors for each library (sample)\nand puts this information in the `samples` data frame. Note that it takes dge\n(our `DGEList` object as input) and returns a `DGEList` object as well.\n\nLet's take a look at our normalisation factors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndge$samples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                             files group lib.size norm.factors\n10_6_5_11 GSM1545535_10_6_5_11.txt    LP 32857304    0.8943956\n9_6_5_11   GSM1545536_9_6_5_11.txt    ML 35328624    1.0250186\npurep53     GSM1545538_purep53.txt Basal 57147943    1.0459005\nJMS8-2       GSM1545539_JMS8-2.txt Basal 51356800    1.0458455\nJMS8-3       GSM1545540_JMS8-3.txt    ML 75782871    1.0162707\nJMS8-4       GSM1545541_JMS8-4.txt    LP 60506774    0.9217132\nJMS8-5       GSM1545542_JMS8-5.txt Basal 55073018    0.9961959\nJMS9-P7c   GSM1545544_JMS9-P7c.txt    ML 21305254    1.0861026\nJMS9-P8c   GSM1545545_JMS9-P8c.txt    LP 19955335    0.9839203\n```\n\n\n:::\n:::\n\n\nThese normalisation factors are all close to 1 for all samples, suggesting\nminimal difference in relative RNA levels between samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(log(dge$counts + 0.5))\n```\n\n::: {.cell-output-display}\n![](session_5_files/figure-html/unnamed-chunk-6-1.png){width=2000}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(cpm(dge$counts, log = TRUE))\n```\n\n::: {.cell-output-display}\n![](session_5_files/figure-html/unnamed-chunk-7-1.png){width=2000}\n:::\n:::\n\n\n## MDS plots\n\nBefore we perform statistical tests, it's useful to perform some exploratory\nvisual analysis to get an overall idea of how our data is behaving.\n\nMDS is a way to visualise distances between sets of data points\n(samples in our case). It is a dimensionality reduction technique, similar to\nprincipal components analysis (PCA). We treat gene expression in samples as if\nthey were coordinates in a high-dimensional coordinate system, then we can find\n\"distances\" between samples as we do between points in space. Then the goal of\nthe algorithm is to find a representation in lower dimensional space such that\npoints that the distance of two objects from each other in high dimensional\nspace is preserved in lower dimensions.\n\nThe `plotMDS()` from `limma` creates an MDS plot from a `DGEList` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotMDS(dge)\n```\n\n::: {.cell-output-display}\n![](session_5_files/figure-html/unnamed-chunk-8-1.png){width=2000}\n:::\n:::\n\n\nEach point on the plot represents one sample and is 'labelled' using the sample\nname. The distances between each sample in the resulting plot can be interpreted\nas the typical log2-fold-change between the samples, for the most differentially\nexpressed genes.\n\nWe can change the labelling to use the name of the group the sample belongs to\ninstead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotMDS(dge, labels = group)\n```\n\n::: {.cell-output-display}\n![](session_5_files/figure-html/unnamed-chunk-9-1.png){width=2000}\n:::\n:::\n\n\nThis shows us that the phenotype groups tend to cluster together, meaning that\nthe gene expression profiles are similar for samples within a phenotype group.\nThe 'Basal' type samples quite close together while the 'LP'\n(luminal progenitor) and 'ML' (mature luminal) type samples are further apart,\nsignifying that their expression profiles are more variable.\n\nTo make the three phenotype groups more distinct in our graph, we are going to\ncolour samples from each group differently. To do this, we will use the `col`\nargument in `plotMDS()`. `col` takes in a vector the same length as the number\nof points in the plot (9 in our case, as there are 9 samples). Each element of\nthe vector should be a colour name (R understands\n[over 600 colour names](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)),\nindicating what colour that sample should be.\n\nTo make this more clear, take a look at the table below, which lists all the\nsamples and the phenotype group they belong to:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ purrr     1.0.2\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract()    masks magrittr::extract()\n✖ dplyr::filter()     masks stats::filter()\n✖ dplyr::group_rows() masks kableExtra::group_rows()\n✖ dplyr::lag()        masks stats::lag()\n✖ purrr::set_names()  masks magrittr::set_names()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Samples </th>\n   <th style=\"text-align:left;\"> Group </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 10_6_5_11 </td>\n   <td style=\"text-align:left;\"> LP </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 9_6_5_11 </td>\n   <td style=\"text-align:left;\"> ML </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> purep53 </td>\n   <td style=\"text-align:left;\"> Basal </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JMS8-2 </td>\n   <td style=\"text-align:left;\"> Basal </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JMS8-3 </td>\n   <td style=\"text-align:left;\"> ML </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JMS8-4 </td>\n   <td style=\"text-align:left;\"> LP </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JMS8-5 </td>\n   <td style=\"text-align:left;\"> Basal </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JMS9-P7c </td>\n   <td style=\"text-align:left;\"> ML </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JMS9-P8c </td>\n   <td style=\"text-align:left;\"> LP </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nFor example, let's say we wanted LP samples to be coloured green, ML samples to\nbe coloured red and Basal samples to be coloured blue. The `col` argument would\nthen require a vector that we can generate as follows\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_col <- dge$samples$group\nlevels(group_col) <- c(\"blue\", \"green\", \"red\")\ngroup_col <- as.character(group_col)\ngroup_col\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"green\" \"red\"   \"blue\"  \"blue\"  \"red\"   \"green\" \"blue\"  \"red\"   \"green\"\n```\n\n\n:::\n:::\n\n\nWe can also add a legend to the figure by running the `legend()` function\nimmediately after a new figure is created. We have to specify where to position\nthe legend as well as the labels and colours within the legend.\n\nTODO: Helper functions?\nTODO: Convert all plots to ggplot and provide reasoning\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmds_data <- plotMDS(dge, labels = group, col = group_col)\nlegend(\n  \"topright\",\n  legend = c(\"Basal\", \"LP\", \"ML\"),\n  fill = c(\"blue\", \"green\", \"red\")\n)\n```\n\n::: {.cell-output-display}\n![](session_5_files/figure-html/unnamed-chunk-12-1.png){width=2000}\n:::\n\n```{.r .cell-code}\nmds_tibble <- tibble(\n    x = mds_data$x,\n    y = mds_data$y,\n    label = colnames(dge),\n    group = dge$samples$group\n)\n\nmds_tibble %>%\n    ggplot(aes(x = x, y = y, col = group)) +\n    geom_point(size = 3)\n```\n\n::: {.cell-output-display}\n![](session_5_files/figure-html/unnamed-chunk-12-2.png){width=2000}\n:::\n:::\n",
    "supporting": [
      "session_5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}