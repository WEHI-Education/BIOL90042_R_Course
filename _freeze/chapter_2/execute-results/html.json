{
  "hash": "449512e07fe23a6276bcb98bbcc87a94",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters:\n  - naquiz\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-title: \"In this chapter:\"\n---\n\n\n\n\n\n# Working with data - Part 1 {#sec-chapter02}\n\nIn this chapter we will learn how to manipulate and summarise data using the `dplyr` package (with a little help from the `tidyr` package too).\n\n::: {.callout-tip title=\"Learning Objectives\"}\nAt the end of this chapter, learners should be able to:\n\n1.  Use the pipe (`%>%`) to chain multiple functions together\n\n2.  Design chains of dplyr functions to manipulate data frames\n\n3.  Understand how to identify and handle missing values in a data frame\n\n4.  Apply grouping for more complex analysis of data\n\n5.  Recall how to save data frames to a file\n:::\n\nBoth `dplyr` and `tidyr` are contained within the `tidyverse` (along with `readr`) so we can load all of these packages at once using `library(tidyverse)`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# don't forget to load tidyverse!\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\n\n## Chaining functions together with pipes {#sec-pipes}\n\nPipes are a powerful feature of the `tidyverse` that allow you to chain multiple functions together.\nPipes are useful because they allow you to break down complex operations into smaller steps that are easier to read and understand.\n\nFor example, take the following code:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, 2, 3, 4, 5)\nas.character(round(mean(my_vector)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"\n```\n\n\n:::\n:::\n\n\n\n\n\nWhat do you think this code does?\nIt calculates the mean of `my_vector`, rounds the result to the nearest whole number, and then converts the result to a character.\nBut the code is a bit hard to read because you have to start from the inside of the brackets and work your way out.\n\nInstead, we can use the pipe operator (`%>%`) to chain these functions together in a more readable way:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, 2, 3, 4, 5)\nmy_vector %>% mean() %>% round() %>% as.character()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"\n```\n\n\n:::\n:::\n\n\n\n\n\nSee how the code reads naturally from left to right?\nYou can think of the pipe as being like the phrase \"and then\".\nHere, we're telling R: \"Take `my_vector`, and then calculate the mean, and then round the result, and then convert it to a character.\"\n\nYou'll notice that we didn't need to specify the input to each function.\nThat's because the pipe automatically passes the output of the previous function as the first input to the next function.\nWe can still specify additional arguments to each function if we need to.\nFor example, if we wanted to round the mean to 2 decimal places, we could do this:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector %>% mean() %>% round(digits = 2) %>% as.character()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"\n```\n\n\n:::\n:::\n\n\n\n\n\nR is clever enough to know that the first argument to `round()` is still the output of `mean()`, even though we've now specified the `digits` argument.\n\n::: {.callout-note title=\"Plenty of pipes\"}\nThere is another style of pipe in R, called the 'base R pipe' `|>`, which is available in R version 4.1.0 and later.\nThe base R pipe works in a similar way to the `magrittr` pipe (`%>%`) that we use in this course, but it is not as flexible.\nWe recommend using the `magrittr` pipe for now.\n\nFun fact: the `magrittr` package is named after the [artist René Magritte, who made a famous painting of a pipe](https://en.wikipedia.org/wiki/The_Treachery_of_Images).\n:::\n\nTo type the pipe operator more easily, you can use the keyboard shortcut {{< kbd Cmd-shift-M >}} (although once you get used to it, you might find it easier to type `%>%` manually).\n\n::::::::::::::: {.callout-important title=\"Practice exercises\"}\nTry these practice questions to test your understanding\n\n:::::::: question\n1\\.\nWhat is NOT a valid way to re-write the following code using the pipe operator: `round(sqrt(sum(1:10)), 1)`.\nIf you're not sure, try running the different options in the console to see which one gives the same answer.\n\n::::::: choices\n::: choice\n`1:10 %>% sum() %>% sqrt() %>% round(1)`\n:::\n\n::: {.choice .correct-choice}\n`sum(1:10) %>% sqrt(1) %>% round()`\n:::\n\n::: choice\n`1:10 %>% sum() %>% sqrt() %>% round(digits = 1)`\n:::\n\n::: choice\n`sum(1:10) %>% sqrt() %>% round(digits = 1)`\n:::\n:::::::\n::::::::\n\n:::::::: question\n2\\.\nWhat is the output of the following code?\n`letters %>% head() %>% toupper()` Try to guess it before copy-pasting into R.\n\n::::::: choices\n::: choice\n`\"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"`\n:::\n\n::: choice\n`\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"`\n:::\n\n::: choice\nAn error\n:::\n\n::: {.choice .correct-choice}\n`\"A\" \"B\" \"C\" \"D\" \"E\" \"F\"`\n:::\n:::::::\n::::::::\n\n<details>\n\n<summary>Solutions</summary>\n\n<p>\n\n1.  The invalid option is `sum(1:10) %>% sqrt(1) %>% round()`. This is because the `sqrt()` function only takes one argument, so you can't specify `1` as an argument in addition to what is being piped in from `sum(1:10)`. Note that some options used the pipe to send `1:10` to `sum()` (like `1:10 %>% sum()`), and others just used `sum(1:10)` directly. Both are valid ways to use the pipe, it's just a matter of personal preference.\n2.  The output of the code `letters %>% head() %>% toupper()` is `\"A\" \"B\" \"C\" \"D\" \"E\" \"F\"`. The `letters` vector contains the lowercase alphabet, and the `head()` function returns the first 6 elements of the vector. Finally, the `toupper()` function then converts these elements to uppercase.\n\n</p>\n\n</details>\n:::::::::::::::\n\n## Basic data manipulation {#sec-dataManip}\n\nTo really see the power of the pipe, we will use it together with the `dplyr` package that provides a set of functions to easily filter, sort, select, modify and summarise data frames.\nThese functions are designed to work well with the pipe, so you can chain them together to create complex data manipulations in a readable format.\n\nFor example, even though we haven't covered the `dplyr` functions yet, you can probably guess what the following code does:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the pipe to chain together our data manipulation steps\nm_dose %>%\n  filter(cage_number == \"3E\") %>%\n  pull(weight_lost_g) %>%\n  mean()\n```\n:::\n\n\n\n\n\nThis code filters the `m_dose` data frame to only include data from cage 3E, then pulls out the `weight_lost_g` column, and finally calculates the mean of the values in that column.\nThe first argument to each function is the output of the previous function, and any additional arguments (like the column name in `pull()`) are specified in the brackets (like `round(digits = 2)` from the previous example).\n\nWe also used the enter key after each pipe `%>%` to break up the code into multiple lines to make it easier to read.\nThis isn't required, but is a popular style in the R community, so all the code examples in this chapter will follow this format.\n\nWe will now introduce some of the most commonly used `dplyr` functions for manipulating data frames.\nTo showcase these, we will use the `m_dose` that we practiced reading in last chapter.\nThis imaginary dataset contains information on the weight lost by different strains of mice after being treated with different doses of MouseZempic®.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the data, like we did in chapter 1\nm_dose <- read_delim(\"data/mousezempic_dosage_data.csv\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (5): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g, id_num\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n\n\nBefore we start, let's use what we learned in the previous chapter to take a look at `m_dose`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# it's a tibble, so prints nicely\nm_dose\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nYou might also like to use `View()` to open the data in a separate window and get a closer look.\n\n::: {.callout-note title=\"Using RStudio autocomplete\"}\nAlthough it's great to give our data a descriptive name like `m_dose`, it can be a bit of a pain to type out every time.\nLuckily, RStudio has a handy autocomplete feature that can solve this problem.\nJust start typing the name of the object, and you'll see it will popup:\n\n![RStudio autocomplete](images/S02F01_rstudio_autocomplete.png)\n\nYou can then press {{< kbd Tab >}} to autocomplete it.\nIf there are multiple objects that start with the same letters, you can use the arrow keys to cycle through the options.\n\nTry using autocomplete in this chapter to save yourself some typing!\n:::\n\n### Sorting data {#sec-sorting}\n\nOften, one of the first things you might want to do with a dataset is sort it.\nIn `dplyr`, this is called 'arranging' and is done with the `arrange()` function.\n\n![Arrange orders rows by their values in one or more columns](images/S02F02_arrange.png)\n\nBy default, `arrange()` sorts in ascending order (smallest values first).\nFor example, let's sort the `m_dose` data frame by the `weight_lost_g` column:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  arrange(weight_lost_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 CD-1         3E                   2.85 rep2      female     0.00181\n 3 CD-1         3E                   2.85 rep2      female     0.00184\n 4 CD-1         3E                   2.9  rep2      female     0.00187\n 5 CD-1         2B                   2.9  rep2      female     0.00178\n 6 CD-1         1A                   2.9  rep3      female     0.00188\n 7 BALB C       2B                   2.9  rep1      female     0.00187\n 8 CD-1         3E                   2.92 rep3      female     0.00193\n 9 CD-1         2B                   2.98 rep1      <NA>       0.00179\n10 CD-1         2B                   3    rep1      female     0.00185\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nIf we compare this to when we just printed our data above, we can see that the rows are now sorted so that the mice that lost the least weight are at the top.\n\nSometimes you might want to sort in descending order instead (largest values first).\nYou can do this by putting the `desc()` function around your column name, inside `arrange()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  # put desc() around the column name to sort in descending order\n  arrange(desc(weight_lost_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nNow we can see the mice that lost the most weight are at the top.\n\n::: {.callout-note title=\"Comments and pipes\"}\nNotice how in the previous example we have written a comment in the middle of the pipe chain.\nThis is a good practice to help you remember what each step is doing, especially when you have a long chain of functions, and won't cause any errors as long as you make sure that the comment is on its own line.\n\nYou can also write comments at the end of the line, just make sure it's after the pipe operator `%>%`.\n\nFor example, these comments are allowed:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>% # a comment here is fine\n  # a comment here is fine\n  arrange(desc(weight_lost_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nBut this will cause an error, because the `#` is before the pipe, so R treats it as part of the comment (notice how the `%>%` has changed colour?) and doesn't know how the two lines relate to each other.\nIt tries to run them separately, which for the first line is ok (it will just print `m_dose`):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose # this comment will cause an error %>%\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n  arrange(desc(weight_lost_g))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'weight_lost_g' not found\n```\n\n\n:::\n:::\n\n\n\n\n\nBut for the second line, there is an error that R doesn't know what the `weight_lost_g` object is.\nThat's because it's a column in the `m_dose` data frame, so R only knows what it is in the context of the pipe chain containing that data frame.\n:::\n\nYou can also sort by multiple columns by passing multiple column names to `arrange()`.\nFor example, to sort by the strain first and then by the amount of weight lost:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sort by strain first, then by weight lost\nm_dose %>%\n  arrange(mouse_strain, weight_lost_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 BALB C       2B                   2.9  rep1      female     0.00187\n 3 BALB C       2B                   3.2  rep2      female     0.00187\n 4 BALB C       2B                   3.25 rep1      female     0.00178\n 5 BALB C       2B                   3.25 rep3      male       0.00187\n 6 BALB C       2B                   3.25 rep3      female     0.00191\n 7 BALB C       2B                   3.3  rep1      male       0.00197\n 8 BALB C       2B                   3.3  rep1      female     0.00195\n 9 BALB C       2B                   3.32 rep3      female     0.00199\n10 BALB C       2B                   3.35 rep2      female     0.00187\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nThis will sort the data frame by strain (according to alphabetical order, as it is a character column), and within each strain, they are then sorted by the amount of weight lost.\n\n::: {.callout-note title=\"Piping into View()\"}\nIn the above example, we sorted the data by strain and then by weight lost, but because there are so many mice in each strain, the preview shown in our console doesn't allow us to see the full effect of the sorting.\n\nOne handy trick you can use with pipes is to add `View()` at the end of your chain to open the data in a separate window.\nTry running this code, and you'll be able to scroll through the full dataset to check that the other mouse strains have also been sorted correctly:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sort by strain first, then by weight lost\nm_dose %>%\n  arrange(mouse_strain, weight_lost_g) %>%\n  View()\n```\n:::\n\n\n\n\n\nThis is a great way to check that your code has actually done what you intended!\n:::\n\n#### Extracting rows with the smallest or largest values {#sec-sliceMinMax}\n\nSlice functions are used to select rows based on their position in the data frame.\nThe `slice_min()` and `slice_max()` functions are particularly useful, because they allow you to select the rows with the smallest or largest values in a particular column.\n\nThis is equivalent to using `arrange()` followed by `head()`, but is more concise:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the 10 mice with the lowest drug dose\nm_dose %>%\n  # slice_min() requires the column to sort by, and n = the number of rows to keep\n  slice_min(drug_dose_g, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         3E                   3.15 rep1      female     0.00172\n 2 CD-1         3E                   3.4  rep1      female     0.00174\n 3 CD-1         1A                   3.45 rep3      female     0.00176\n 4 CD-1         2B                   3.25 rep1      female     0.00178\n 5 CD-1         2B                   3.9  rep1      male       0.00178\n 6 CD-1         2B                   2.9  rep2      female     0.00178\n 7 BALB C       2B                   3.25 rep1      female     0.00178\n 8 CD-1         2B                   2.98 rep1      <NA>       0.00179\n 9 CD-1         1A                   3.7  rep1      <NA>       0.0018 \n10 CD-1         3E                   3.6  rep1      male       0.0018 \n11 CD-1         3E                   3.8  rep1      male       0.0018 \n12 CD-1         3E                   3.95 rep1      male       0.0018 \n13 CD-1         2B                   3.55 rep1      female     0.0018 \n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n# get the top 5 mice that lost the most weight\nm_dose %>%\n  # slice_max() has the same arguments as slice_min()\n  slice_max(weight_lost_g, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n6 Black 6      3E                   5.95 rep3      male      0.00229\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nBut wait— neither of those pieces of code actually gave the number of rows we asked for!\nIn the first example, we asked for the 10 mice with the lowest drug dose, but we got 13.\nAnd in the second example, we asked for the top 5 mice that lost the most weight, but we got 6.\nWhy aren't the `slice_` functions behaving as expected?\n\nIf we take a look at the help page (type `?slice_min` in the console), we learn that `slice_min()` and `slice_max()` have an argument called `with_ties` that is set to `TRUE` by default.\nIf we want to make sure we only get the number of rows we asked for, we would have to set it to `FALSE`, like so:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the top 5 mice that lost the most weight\nm_dose %>%\n  # no ties allowed!\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nThis is an important lesson: sometimes functions will behave in a way that is unexpected, and you might need to read their help page or use other guides/google/AI to understand why.\n\n::::::::::::::::::::: {.callout-important title=\"Practice exercises\"}\nTry these practice questions to test your understanding\n\n:::::::: question\n1\\.\nWhich code would you use to sort the `m_dose` data frame from biggest to smallest initial weight?\n\n::::::: choices\n::: choice\n`m_dose %>% sort(initial_weight_g)`\n:::\n\n::: choice\n`m_dose %>% arrange(initial_weight_g)`\n:::\n\n::: choice\n`m_dose %>% sort(descending(initial_weight_g))`\n:::\n\n::: {.choice .correct-choice}\n`m_dose %>% arrange(desc(initial_weight_g))`\n:::\n:::::::\n::::::::\n\n:::::::: question\n2\\.\nWhich code would you use to extract the 3 mice with the highest initial weight from the `m_dose` data frame?\n\n::::::: choices\n::: {.choice .correct-choice}\n`m_dose %>% slice_max(initial_weight_g, n = 3)`\n:::\n\n::: choice\n`m_dose %>% arrange(desc(initial_weight_g))`\n:::\n\n::: choice\n`m_dose %>% slice_min(initial_weight_g, n = 3)`\n:::\n\n::: choice\n`m_dose %>% arrange(initial_weight_g)`\n:::\n:::::::\n::::::::\n\n:::::::: question\n3\\.\nI've written the below code, but one of the comments is messing it up!\nWhich one?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# comment A\nm_dose # comment B %>%\n  # comment C\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE) # comment D\n```\n:::\n\n\n\n\n\n::::::: choices\n::: choice\nComment A\n:::\n\n::: {.choice .correct-choice}\nComment B\n:::\n\n::: choice\nComment C\n:::\n\n::: choice\nComment D\n:::\n:::::::\n::::::::\n\n<details>\n\n<summary>Solutions</summary>\n\n1.  The correct code to sort the `m_dose` data frame from biggest to smallest initial weight is `m_dose %>% arrange(desc(initial_weight_g))`.\n    The `arrange()` function is used to sort the data frame (although there is a `sort()` function in R, that's not part of dplyr and won't work the same way), and the `desc()` function is used to sort in descending order.\n\n2.  The correct code to extract the 3 mice with the highest initial weight from the `m_dose` data frame is `m_dose %>% slice_max(initial_weight_g, n = 3)`.\n    The `slice_max()` function is used to select the rows with the largest values in the `initial_weight_g` column, and the `n = 3` argument specifies that we want to keep 3 rows.\n    The `arrange()` function is not needed in this case, because `slice_max()` will automatically sort the data frame by the specified column.\n\n3.  The comment that is messing up the code is Comment B. The `#` symbol is before the pipe operator `%>%`, so R treats it as part of the comment and this breaks our chain of pipes.\n    The other comments are fine, because they are either at the end of the line or on their own line.\n    Basically, if a comment is changing the colour of the pipe operator (or any other bits of your code), it's in the wrong place!\n\n</details>\n:::::::::::::::::::::\n\n### Filtering data (rows) {#sec-filter}\n\n![Filter allows you to filter rows using a logical test](images/S02F03_filter.png)\n\nIn `dplyr`, the `filter()` function is used to subset rows based on their values.\nYou provide a logical test, and `filter()` will keep the rows where the test is `TRUE`.\nWe can write these tests using the comparison operators we learned in the previous chapter (e.g. `==`, `<` and `!=`, see [Section @sec-comparisons]).\n\nFor example, to filter the `m_dose` data frame to only include mice that lost more than 6g:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  filter(weight_lost_g > 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nOr to only include mice from cage 3E:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  # remember that == is used for testing equality\n  filter(cage_number == \"3E\") # don't forget the quotes either!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 168 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         3E                   3.4  rep1      female     0.00174\n 2 CD-1         3E                   3.6  rep1      male       0.0018 \n 3 CD-1         3E                   3.8  rep1      female     0.00189\n 4 CD-1         3E                   3.95 rep1      male       0.00185\n 5 CD-1         3E                   3.8  rep1      male       0.0018 \n 6 CD-1         3E                   3.8  rep1      female     0.00187\n 7 CD-1         3E                   3.55 rep1      male       0.00183\n 8 CD-1         3E                   3.2  rep1      female     0.00187\n 9 CD-1         3E                   3.15 rep1      female     0.00172\n10 CD-1         3E                   3.95 rep1      male       0.0018 \n# ℹ 158 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n#### Combining logical tests\n\nSometimes we want to filter based on multiple conditions.\nHere we will show some more advanced operators that can be used to combine logical tests.\n\nThe `&` operator is used to combine two logical tests with an 'and' condition.\nFor example, to filter the data frame to only include mice that have a tail length greater than 19mm and are female:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  filter(tail_length_mm > 19 & sex == \"female\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 9\n  mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n  <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n1 CD-1         1A                   3.45 rep1      female     0.00193\n2 CD-1         3E                   3.8  rep1      female     0.00189\n3 CD-1         2B                   3.3  rep1      female     0.00181\n4 CD-1         3E                   3.9  rep3      female     0.00191\n5 BALB C       2B                   3.52 rep3      female     0.00194\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nThe `|` operator is used to combine two logical tests with an 'or' condition.\nFor example, to filter the data frame to only include mice that have an initial weight less than 35g or a tail length less than 14mm:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  filter(initial_weight_g < 35 | tail_length_mm < 14)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 30 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.48 rep1      <NA>       0.00193\n 2 CD-1         1A                   4.4  rep1      male       0.00198\n 3 CD-1         1A                   3.32 rep1      female     0.00184\n 4 CD-1         3E                   2.9  rep2      female     0.00187\n 5 CD-1         1A                   3.6  rep2      female     0.0019 \n 6 CD-1         1A                   3.2  rep2      female     0.00189\n 7 CD-1         2B                   3.4  rep2      female     0.00185\n 8 CD-1         2B                   2.9  rep2      female     0.00178\n 9 CD-1         2B                   3.05 rep3      female     0.00188\n10 Black 6      3E                   4.5  rep1      female     0.00211\n# ℹ 20 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nThe `%in%` operator can be used to filter based on a vector of multiple values (`c(x, y)`).\nIt's particularly useful when you have a few character values you want to filter on, as it is shorter to type than `|` (or).\n\nFor example, to filter the data frame to only include mice from cages 3E or 1A, we could use `|` like this:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  filter(cage_number == \"3E\" | cage_number == \"1A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 220 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 210 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nOr we could use `%in%` like this:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  filter(cage_number %in% c(\"3E\", \"1A\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 220 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 210 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n::::::::::::::::::::: {.callout-important title=\"Practice exercises\"}\nTry these practice questions to test your understanding\n\n:::::::: question\n1\\.\nWhich code would you use to filter the `m_dose` data frame to only include mice from replicate 2?\n\n::::::: choices\n::: choice\n`m_dose %>% filter(replicate == 2)`\n:::\n\n::: choice\n`m_dose %>% filter(replicate == rep2)`\n:::\n\n::: {.choice .correct-choice}\n`m_dose %>% filter(replicate == \"rep2\")`\n:::\n\n::: choice\n`m_dose %>% filter(replicate = \"rep2\")`\n:::\n:::::::\n::::::::\n\n:::::::: question\n2\\.\nWhat is NOT a valid way to filter the `m_dose` data frame to only include mice that lost more than 4g, and have an initial weight less than 40g?\n\n::::::: choices\n::: choice\n`m_dose %>% filter(weight_lost_g > 4) %>% filter(initial_weight_g < 40)`\n:::\n\n::: {.choice .correct-choice}\n`m_dose %>% filter(weight_lost_g > 4) %>% (initial_weight_g < 40)`\n:::\n\n::: choice\n`m_dose %>% filter(weight_lost_g > 4 & initial_weight_g < 40)`\n:::\n\n::: choice\n`m_dose %>% filter(initial_weight_g < 40) %>% filter(weight_lost_g > 4)`\n:::\n:::::::\n::::::::\n\n:::::::: question\n3\\.\nWhich option correctly describes what the following code is doing?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  filter(mouse_strain %in% c(\"BALB C\", \"Black 6\")) %>%\n  filter(weight_lost_g > 3 & weight_lost_g < 5) %>%\n  arrange(desc(drug_dose_g))\n```\n:::\n\n\n\n\n\n::::::: choices\n::: choice\nFilters the data frame to remove mice from the \"BALB C\" and \"Black 6\" strains, who only lost between 3 and 5g of weight, and then sorts the data frame by drug dose.\n:::\n\n::: choice\nFilters the data frame to remove mice from the \"BALB C\" and \"Black 6\" strains, that lost between 3 and 5g of weight, and then sorts the data frame by drug dose in descending order.\n:::\n\n::: choice\nFilters the data frame to only include mice from the \"BALB C\" and \"Black 6\" strains, that lost between 3 and 5g of weight, and then sorts the data frame by drug dose.\n:::\n\n::: {.choice .correct-choice}\nFilters the data frame to only include mice from the \"BALB C\" and \"Black 6\" strains, that lost between 3 and 5g of weight, and then sorts the data frame by drug dose in descending order.\n:::\n:::::::\n::::::::\n\n<details>\n\n<summary>Solutions</summary>\n\n1.  The correct code to filter the `m_dose` data frame to only include mice from replicate 2 is `m_dose %>% filter(replicate == \"rep2\")`.\n    Option A is incorrect because `2` is not a value of `replicate` (when filtering you need to know what values are actually in your columns! So make sure to `View()` your data first).\n    Option B is incorrect because the replicate column is a character column, so you need to use quotes around the value you are filtering on.\n    Option D is incorrect because `=` is not the correct way to test for equality, you need to use `==`.\n\n2.  The invalid option is `m_dose %>% filter(weight_lost_g > 4) %>% (initial_weight_g < 40)`.\n    This is because the second filtering step is missing the name of the filter function, so R doesn't know what to do with `(initial_weight_g < 40)`.\n    The other options are valid ways to filter the data frame based on the specified conditions; note that we can use multiple `filter()` functions in a row to apply multiple conditions, or the `&` operator to combine them into a single `filter()` function.\n    It's just a matter of personal preference.\n\n3.  The correct description of the code is that it filters the data frame to only include mice from the \"BALB C\" and \"Black 6\" strains, then filters those further to only those that lost between 3 and 5g of weight, and finally sorts the data frame by drug dose in descending order.\n\n</details>\n:::::::::::::::::::::\n\n### Dealing with missing values {#sec-missing}\n\nMissing values are a common problem in real-world datasets.\nIn R, missing values are represented by `NA`.\nIn fact, if you look at the `m_dose` data frame we've been using, you'll see that some of the cells contain `NA`: try spotting them with the `View()` function.\n\nYou can also find missing values in a data frame using the `is.na()` function in combination with `filter()`.\nFor example, to find all the rows in the `m_dose` data frame that have a missing value for the `drug_dose_g` column:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  filter(is.na(drug_dose_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n1 CD-1         1A                     NA rep1      <NA>           NA\n2 Black 6      3E                     NA rep3      <NA>           NA\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nThe problem with missing values is that they can cause problems when you try to perform calculations on your data.\nFor example, if you try to calculate the mean of a column that contains even a single missing value, the result will also be `NA`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try to calculate the mean of the drug_dose_g column\n# remember from chapter 1 that we can use $ to access columns in a data frame\nm_dose$drug_dose_g %>% mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\n\n`NA` values in R are therefore referred to as 'contagious': if you put an `NA` in you usually get an `NA` out.\nIf you think about it, that makes sense— when we don't know the value of a particular mouse's drug dose, how can we calculate the average?\nThat missing value could be anything.\n\nFor this reason, it's important to deal with missing values before performing calculations.\nMany functions in R will have an argument called `na.rm` that you can set to `TRUE` to remove missing values before performing the calculation.\nFor example, to calculate the mean of the `drug_dose_g` column with the missing values excluded:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try to calculate the mean of the drug_dose_g column\n# remember from chapter 1 that we can use $ to access columns in a data frame\nm_dose$drug_dose_g %>% mean(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.002009152\n```\n\n\n:::\n:::\n\n\n\n\n\nThis time, the result is a number, because the missing values have been removed before the calculation.\n\nBut not all functions have an `na.rm` argument.\nIn these cases, you can remove rows with missing values.\nThis can be done for a single column, using the `filter()` function together with `is.na()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove rows with missing values in the drug_dose_g column\nm_dose %>%\n  # remember the ! means 'not', it negates the result of is.na()\n  filter(!is.na(drug_dose_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                   3.45 rep1      female     0.00193\n 5 CD-1         1A                   3.65 rep1      male       0.0019 \n 6 CD-1         1A                   3.62 rep1      female     0.00181\n 7 CD-1         1A                   4.68 rep1      male       0.00195\n 8 CD-1         1A                   3.48 rep1      <NA>       0.00193\n 9 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n10 CD-1         1A                   3.3  rep1      <NA>       0.00186\n# ℹ 332 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nOr, you can remove rows with missing values in any column using the `na.omit()` or `drop_na()` function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove rows with missing values in any column\nm_dose %>%\n  na.omit()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                   3.45 rep1      female     0.00193\n 5 CD-1         1A                   3.65 rep1      male       0.0019 \n 6 CD-1         1A                   3.62 rep1      female     0.00181\n 7 CD-1         1A                   4.68 rep1      male       0.00195\n 8 CD-1         1A                   3.2  rep1      female     0.00182\n 9 CD-1         1A                   3.8  rep1      male       0.00191\n10 CD-1         1A                   4.4  rep1      male       0.00198\n# ℹ 323 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\nm_dose %>%\n  drop_na()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                   3.45 rep1      female     0.00193\n 5 CD-1         1A                   3.65 rep1      male       0.0019 \n 6 CD-1         1A                   3.62 rep1      female     0.00181\n 7 CD-1         1A                   4.68 rep1      male       0.00195\n 8 CD-1         1A                   3.2  rep1      female     0.00182\n 9 CD-1         1A                   3.8  rep1      male       0.00191\n10 CD-1         1A                   4.4  rep1      male       0.00198\n# ℹ 323 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nSometimes, instead of removing rows with missing values, you might want to replace them with a specific value.\nThis can be done using the `replace_na()` function from the `tidyr` package.\n`replace_na()` takes a `list()` which contains each of the column names you want to edit, and the value that should be used.\n\nFor example, to replace missing values in the `weight_lost_g` columns with 0, replace missing values in the `sex` column with 'unknown' and leave the rest of the data frame unchanged:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# replace missing values in the drug_dose_g column with 0\nm_dose %>%\n  # here we need to provide the column_names = values_to_replace\n  # this needs to be contained within a list()\n  replace_na(list(weight_lost_g = 0, sex = \"unknown\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex     drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>         <dbl>\n 1 CD-1         1A                   3.75 rep1      male        0.00181\n 2 CD-1         1A                   3.8  rep1      female      0.00186\n 3 CD-1         1A                   3.25 rep1      female      0.00195\n 4 CD-1         1A                   0    rep1      unknown    NA      \n 5 CD-1         1A                   3.45 rep1      female      0.00193\n 6 CD-1         1A                   3.65 rep1      male        0.0019 \n 7 CD-1         1A                   3.62 rep1      female      0.00181\n 8 CD-1         1A                   4.68 rep1      male        0.00195\n 9 CD-1         1A                   3.48 rep1      unknown     0.00193\n10 CD-1         1A                   4.25 rep1      unknown     0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nWhen deciding how to handle missing values, you might have prior knowledge that `NA` should be replaced with a specific value, or you might decide that removing rows with `NA` is the best approach for your analysis.\n\nFor example, maybe we knew that the mice were given a `weight_lost_g` of `NA` if they didn't lose any weight, it would then make sense to replace those with 0 (as we did in the code above).\nHowever, if the `drug_dose_g` column was missing simply because the data was lost, we might choose to remove those rows entirely.\n\nIt's important to think carefully about how missing values should be handled in your analysis.\n\n::::::::::::::::::::: {.callout-important title=\"Practice exercises\"}\nTry these practice questions to test your understanding\n\n:::::::: question\n1\\.\nWhat would be the result of running this R code: `mean(c(1, 2, 4, NA))`\n\n::::::: choices\n::: choice\n2.333333\n:::\n\n::: choice\n0\n:::\n\n::: {.choice .correct-choice}\n`NA`\n:::\n\n::: choice\nAn error\n:::\n:::::::\n::::::::\n\n:::::::: question\n2\\.\nWhich line of code would you use to filter the `m_dose` data frame to remove mice that have a missing value in the `tail_length_mm` column?\n\n::::::: choices\n::: choice\n`m_dose %>% filter(tail_length_mm != NA)`\n:::\n\n::: choice\n`m_dose %>% filter(is.na(tail_length_mm))`\n:::\n\n::: choice\n`m_dose %>% na.omit()`\n:::\n\n::: {.choice .correct-choice}\n`m_dose %>% filter(!is.na(tail_length_mm))`\n:::\n:::::::\n::::::::\n\n:::::::: question\n3\\.\nHow would you replace missing values in the `initial_weight_g` column with the value 35?\n\n::::::: choices\n::: {.choice .correct-choice}\n`m_dose %>% replace_na(list(initial_weight_g = 35))`\n:::\n\n::: choice\n`m_dose %>% replace_na(initial_weight_g = 35)`\n:::\n\n::: choice\n`m_dose %>% replace_na(list(initial_weight_g == 35))`\n:::\n\n::: choice\n`m_dose %>% replace_na(35)`\n:::\n:::::::\n::::::::\n\n<details>\n\n<summary>Solutions</summary>\n\n<p>\n\n1.  The result of running the code `mean(c(1, 2, 4, NA))` is `NA`. This is because the `NA` value is 'contagious', so when you try to calculate the mean of a vector that contains an `NA`, the result will also be `NA`. If we wanted to calculate the mean of the vector without the `NA`, we would need to use the `na.rm = TRUE` argument.\n2.  The correct line of code to filter the `m_dose` data frame to remove mice that have a missing value in the `tail_length_mm` column is `m_dose %>% filter(!is.na(tail_length_mm))`. The `!` symbol is used to negate the result of `is.na()`, so we are filtering to keep the rows where `tail_length_mm` is not `NA`. We can't use the first option with the `!= NA` because `NA` is a special value in R that represents missing data, and it can't be compared to anything, and the third option is incorrect because `na.omit()` removes entire rows with missing values, rather than just filtering based on a single column.\n3.  The correct line of code to replace missing values in the `initial_weight_g` column with the value 35 is `m_dose %>% replace_na(list(initial_weight_g = 35))`. The `replace_na()` function takes a `list()` that contains the column names you want to replace and the values you want to replace them with. We only need to use a single equal sign here as we're not testing for equality, we're assigning a value.\n\n</p>\n\n</details>\n:::::::::::::::::::::\n\n### Selecting columns {#sec-select}\n\n![Select allows you to select only certain columns](images/S02F04_select.png)\n\nWhile `filter()` is used to subset rows, `select()` is used to subset columns.\nYou can use `select()` to keep only the columns you're interested in, or to drop columns you don't need.\n\nThe `select()` function takes the names of the columns that you want to keep/remove (no vector notation `c()` or quotation marks `\"\"` necessary).\nFor example, to select only the `mouse_strain`, `initial_weight_g`, and `weight_lost_g` columns from the `m_dose` data frame:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  select(mouse_strain, initial_weight_g, weight_lost_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 3\n   mouse_strain initial_weight_g weight_lost_g\n   <chr>                   <dbl>         <dbl>\n 1 CD-1                     39.1          3.75\n 2 CD-1                     39.5          3.8 \n 3 CD-1                     40.3          3.25\n 4 CD-1                     NA           NA   \n 5 CD-1                     36.7          3.45\n 6 CD-1                     39.3          3.65\n 7 CD-1                     38.9          3.62\n 8 CD-1                     39.2          4.68\n 9 CD-1                     34.1          3.48\n10 CD-1                     42            4.25\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can see that all the other columns have been removed from the data frame.\n\nIf you want to keep all columns except for a few, you can use `-` to drop columns.\nFor example, to keep all columns except for `cage_number` and `sex`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  select(-cage_number, -sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 7\n   mouse_strain weight_lost_g replicate drug_dose_g tail_length_mm\n   <chr>                <dbl> <chr>           <dbl>          <dbl>\n 1 CD-1                  3.75 rep1          0.00181           18.7\n 2 CD-1                  3.8  rep1          0.00186           17.4\n 3 CD-1                  3.25 rep1          0.00195           18  \n 4 CD-1                 NA    rep1         NA                 NA  \n 5 CD-1                  3.45 rep1          0.00193           19.3\n 6 CD-1                  3.65 rep1          0.0019            20.6\n 7 CD-1                  3.62 rep1          0.00181           17.8\n 8 CD-1                  4.68 rep1          0.00195           19.6\n 9 CD-1                  3.48 rep1          0.00193           18.1\n10 CD-1                  4.25 rep1          0.0019            20.2\n# ℹ 334 more rows\n# ℹ 2 more variables: initial_weight_g <dbl>, id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nThere are also some helper functions that can be used to select columns based on their names :\n\n+-----------------+---------------------------------------------------+-------------------------------------------------+\n| Function        | Description                                       | Example                                         |\n+=================+===================================================+=================================================+\n| `starts_with()` | select column(s) that start with a certain string | select all columns starting with the letter i   |\n|                 |                                                   |                                                 |\n|                 |                                                   | `select(starts_with(\"i\"))`                      |\n+-----------------+---------------------------------------------------+-------------------------------------------------+\n| `ends_with()`   | select column(s) that end with a certain string   | select all columns ending with \\_g              |\n|                 |                                                   |                                                 |\n|                 |                                                   | `select(ends_with(\"_g\"))`                       |\n+-----------------+---------------------------------------------------+-------------------------------------------------+\n| `contains()`    | select column(s) that contain a certain string    | select all columns containing the word 'weight' |\n|                 |                                                   |                                                 |\n|                 |                                                   | `select(contains(\"weight\"))`                    |\n+-----------------+---------------------------------------------------+-------------------------------------------------+\n\n: There are several helper functions that can be used with the select function\n\nYou need to use quotation marks around the arguments in these helper functions, as they aren't full column names, just strings of characters.\n\nTry using these helper functions to select columns from the `m_dose` data frame!\n\n::: {.callout-note title=\"Reordering columns\"}\n![Relocate allows you to move columns around](images/S02F05_reorder.png)\n\nWe can reorder columns using the `relocate()` function, which works similarly to `select()` (except it just moves columns around rather than dropping/keeping them).\nFor example, to move the `sex` column to before the `cage_number` column:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  # first the name of the column to move, then where it should go\n  relocate(sex, .before = cage_number)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   mouse_strain sex    cage_number weight_lost_g replicate drug_dose_g\n   <chr>        <chr>  <chr>               <dbl> <chr>           <dbl>\n 1 CD-1         male   1A                   3.75 rep1          0.00181\n 2 CD-1         female 1A                   3.8  rep1          0.00186\n 3 CD-1         female 1A                   3.25 rep1          0.00195\n 4 CD-1         <NA>   1A                  NA    rep1         NA      \n 5 CD-1         female 1A                   3.45 rep1          0.00193\n 6 CD-1         male   1A                   3.65 rep1          0.0019 \n 7 CD-1         female 1A                   3.62 rep1          0.00181\n 8 CD-1         male   1A                   4.68 rep1          0.00195\n 9 CD-1         <NA>   1A                   3.48 rep1          0.00193\n10 CD-1         <NA>   1A                   4.25 rep1          0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>,\n#   id_num <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\nWithout a specific position `( .before / .after)`, this function will place the chosen column(s) as the first / left-most columns.\n\nTwo further useful helper functions for `relocate()` are the `everything()` and `last_col()` functions, which can be used to move columns to the start/end of the data frame.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# move id_num to the front\nm_dose %>%\n  relocate(id_num, .before = everything()) # don't forget the brackets\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   id_num mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n    <dbl> <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1      1 CD-1         1A                   3.75 rep1      male       0.00181\n 2      2 CD-1         1A                   3.8  rep1      female     0.00186\n 3      3 CD-1         1A                   3.25 rep1      female     0.00195\n 4      4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5      5 CD-1         1A                   3.45 rep1      female     0.00193\n 6      6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7      7 CD-1         1A                   3.62 rep1      female     0.00181\n 8      8 CD-1         1A                   4.68 rep1      male       0.00195\n 9      9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10     10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n# move mouse_strain to the end\nm_dose %>%\n  relocate(mouse_strain, .after = last_col())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   cage_number weight_lost_g replicate sex    drug_dose_g tail_length_mm\n   <chr>               <dbl> <chr>     <chr>        <dbl>          <dbl>\n 1 1A                   3.75 rep1      male       0.00181           18.7\n 2 1A                   3.8  rep1      female     0.00186           17.4\n 3 1A                   3.25 rep1      female     0.00195           18  \n 4 1A                  NA    rep1      <NA>      NA                 NA  \n 5 1A                   3.45 rep1      female     0.00193           19.3\n 6 1A                   3.65 rep1      male       0.0019            20.6\n 7 1A                   3.62 rep1      female     0.00181           17.8\n 8 1A                   4.68 rep1      male       0.00195           19.6\n 9 1A                   3.48 rep1      <NA>       0.00193           18.1\n10 1A                   4.25 rep1      <NA>       0.0019            20.2\n# ℹ 334 more rows\n# ℹ 3 more variables: initial_weight_g <dbl>, id_num <dbl>, mouse_strain <chr>\n```\n\n\n:::\n:::\n\n\n\n\n\nRe-ordering columns isn't necessary, but it makes it easier to see the data you're most interested in within the console (since often not all of the columns will fit on the screen at once).\nFor example, if we are doing a lot of computation on the `initial_weight_g` column, we'd probably like to have that near the start so we can easily check it.\n:::\n\nNote that the output of the `select()` function is a new data frame, even if you only select a single column:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select the mouse_strain column\nm_dose %>%\n  select(mouse_strain) %>%\n  # recall from chapter 1 that class() tells us the type of an object\n  class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\nSometimes, we instead want to get the values of a column as a vector.\n\n![Pull allows you to pull a column out of a data frame as a vector](images/S02F06_pull.png)\n\nWe can do this by using the `pull()` function, which extracts a single column from a data frame as a vector:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the mouse_strain column as a vector\nm_dose %>%\n  pull(mouse_strain) %>%\n  class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can see that the class of the output is now a vector, rather than a data frame.\nThis is important because some functions only accept vectors, not data frames, like `mean()` for example:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this will give an error\nm_dose %>% select(initial_weight_g) %>% mean(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in mean.default(., na.rm = TRUE): argument is not numeric or logical:\nreturning NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# this will work\nm_dose %>% pull(initial_weight_g) %>% mean(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 43.92193\n```\n\n\n:::\n:::\n\n\n\n\n\nNote how both times we used `na.rm = TRUE` to remove missing values before calculating the mean.\n\nYou might remember that we used the `$` operator in the previous chapter to extract a single column from a data frame, so why use `pull()` instead?\nThe main reason is that `pull()` works within a chain of pipes, whereas `$` doesn't.\n\nFor example, let's say we want to know the average initial weight of mice that lost at least 4g.\nWe can do this by chaining `filter()` and `pull()` together:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_dose %>%\n  # filter to mice that lost at least 4g\n  filter(weight_lost_g >= 4) %>%\n  # get the initial_weight_g column as a vector\n  pull(initial_weight_g) %>%\n  # calculate mean, removing NA values\n  mean(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 46.48023\n```\n\n\n:::\n:::\n\n\n\n\n\n::::::::::::::::::::: {.callout-important title=\"Practice exercises\"}\nTry these practice questions to test your understanding\n\n:::::::: question\n1\\.\nWhich line of code would NOT be a valid way to select only the `drug_dose_g`, `initial_weight_g`, and `weight_lost_g` columns from the `m_dose` data frame?\n\n::::::: choices\n::: choice\n`m_dose %>% select(drug_dose_g, initial_weight_g, weight_lost_g)`\n:::\n\n::: {.choice .correct-choice}\n`m_dose %>% select(contains(\"g\"))`\n:::\n\n::: choice\n`m_dose %>% select(ends_with(\"_g\"))`\n:::\n\n::: choice\n`m_dose %>% select(-cage_number, -tail_length_mm, -id_num, -mouse_strain, -sex, -replicate)`\n:::\n:::::::\n::::::::\n\n:::::::: question\n2\\.\nHow would I extract the `initial_weight_g` column from the `m_dose` data frame as a vector?\n\n::::::: choices\n::: choice\n`m_dose %>% filter(initial_weight_g)`\n:::\n\n::: choice\n`m_dose %>% $initial_weight_g`\n:::\n\n::: choice\n`m_dose %>% select(initial_weight_g)`\n:::\n\n::: {.choice .correct-choice}\n`m_dose %>% pull(initial_weight_g)`\n:::\n:::::::\n::::::::\n\n:::::::: question\n3\\.\nHow would you move the `sex` column to the end of the `m_dose` data frame?\n\n::::::: choices\n::: choice\n`m_dose %>% relocate(sex)`\n:::\n\n::: choice\n`m_dose %>% relocate(sex, .after = last_col)`\n:::\n\n::: {.choice .correct-choice}\n`m_dose %>% relocate(sex, .after = last_col())`\n:::\n\n::: choice\n`m_dose %>% reorder(sex, .after = last_col())`\n:::\n:::::::\n::::::::\n\n<details>\n\n<summary>Solutions</summary>\n\n<p>\n\n1.  The line of code that would NOT be a valid way to select the `drug_dose_g`, `initial_weight_g`, and `weight_lost_g` columns from the `m_dose` data frame is `m_dose %>% select(contains(\"g\"))`. This line of code would select all columns that contain the letter 'g', which would include columns like `cage_number` and `tail_length_mm`. We need to specify either `ends_with(\"g\")` or `contains(\"_g\")` to only get those with `_g` at the end. The other options are valid ways to select the specified columns, although some are more efficient than others!\n2.  The correct way to extract the `initial_weight_g` column from the `m_dose` data frame as a vector is `m_dose %>% pull(initial_weight_g)`. The `pull()` function is used to extract a single column from a data frame as a vector. The other options are incorrect because `filter()` is used to subset rows, `$` is not used in a pipe chain, and `select()` is outputs a data frame, not extract them as vectors.\n3.  The correct way to move the `sex` column to the end of the `m_dose` data frame is using the `relocate()` function like this: `m_dose %>% relocate(sex, .after = last_col())`. The `last_col()` function is used to refer to the last column in the data frame. The other options are incorrect because `reorder()` is not a valid function, and you need to remember to include the brackets `()` when using `last_col()`.\n\n</p>\n\n</details>\n:::::::::::::::::::::\n\n## Summary\n\nHere's what we've covered in this chapter:\n\n-   The pipe operator `%>%` and how we can use it to chain together multiple function calls, making our code more readable and easier to understand.\n\n-   The basic dplyr verbs `arrange()`, `filter()` and `select()`\n\n::: {.callout-note title=\"Why does data need to be tidy anyway?\"}\nIn this chapter, we've been focusing on making our data 'tidy': that is, structured in a consistent way that makes it easy to work with.\nA nice visual illustration of tidy data and its importance can be [found here](https://allisonhorst.com/other-r-fun).\n:::\n\n### Practice questions\n\n1.  What is the purpose of the pipe operator `%>%`?\n    Keeping this in mind, re-write the following code to use the pipe.\n\n    a.  `round(mean(c(1, 2, 3, 4, 5)))`\n    b.  `print(as.character(1 + 10))`\n\n2.  What would be the result of evaluating the following expressions?\n    You don't need to know these off the top of your head, use R to help!\n    (Hint: some expressions might give an error. Try to think about why)\n\n    a.  `m_dose %>% filter(weight_lost_g > 10)`\n    b.  `m_dose %>% select(tail_length_mm, weight_lost_g)`\n    c.  `m_dose %>% arrange(tail_length_mm)`\n    d.  `m_dose %>% filter(initial_Weight_g > 10) %>% arrange(mouse_strain)`\n    e.  `m_dose %>% relocate(mouse_strain, .after = cage_number)`\n    f.  `m_dose %>% pull(weight_lost_g)`\n    g.  `m_dose %>% filter(!is.na(weight_lost_g))`\n    h.  `m_dose %>% replace_na(list(weight_lost_g = 0))`\n\n3.  What is a missing value in R?\n    What are two ways to deal with missing values in a data frame?\n\n<details>\n\n<summary>Solutions</summary>\n\n1.  The pipe operator `%>%` is used to chain together multiple function calls, passing the result of one function to the next.\n    Here's how you could re-write the code to use the pipe:\n\n    a.  `c(1, 2, 3, 4, 5) %>% mean() %>% round()`\n    b.  `as.character(1 + 10) %>% print()`\n\n2.  The result of evaluating the expressions would be:\n\n    a.  A data frame containing only the rows where `weight_lost_g` is greater than 10.\n    b.  A data frame containing only the `tail_length_mm` and `weight_lost_g` columns.\n    c.  A data frame sorted by `tail_length_mm`, in ascending order.\n    d.  An error because `initial_Weight_g` is not a column in the data frame.\n    e.  A data frame with the `mouse_strain` column moved to be after the `cage_number` column.\n    f.  A **vector** containing the values of the `weight_lost_g` column.\n    g.  A data frame containing only the rows where `weight_lost_g` is not `NA`.\n    h.  A data frame with missing values in the `weight_lost_g` column replaced with 0.\n\n3.  A missing value in R is represented by `NA`.\n    Two ways to deal with missing values in a data frame are to remove them using `filter(!is.na(column_name))` or to replace them with a specific value using `replace_na(list(column_name = value))`.\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}