{
  "hash": "959a709ff84ed3b1eababb8ace6f4748",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters:\n  - naquiz\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-title: \"In this session:\"\n---\n\n\n# Session 2: Working with data {#sec-session02}\n\nIn this session we will learn how to manipulate and summarise data using the `dplyr` package.\n\n::: {.callout-tip title=\"Learning Objectives\"}\nAt the end of this session, learners should be able to:\n\n1.  Use the pipe (`%>%`) to chain multiple functions together\n\n2.  Design chains of dplyr functions to manipulate data frames\n\n3.  Apply grouping for more complex analysis of data\n\n4.  Understand how pivot and join functions can be used to reshape and combine entire data frames\n\n5.  Recall how to save data frames to a file\n:::\n\nMake sure you have `dplyr` package loaded by running `library(dplyr)`, otherwise you will not be able to run the code in this session.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# don't forget to load dplyr\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n:::\n\n\nYou'll see some output from the `dplyr` package when you load it, which is just telling you that some of `dplyr`'s functions have the same name as other functions in R.\n\n## Chaining functions together with pipes {#sec-pipes}\n\nPipes are a powerful feature of the `tidyverse` that allow you to chain multiple functions together. Pipes are useful because they allow you to break down complex operations into smaller steps that are easier to read and understand.\n\nFor example, take the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, 2, 3, 4, 5)\nas.character(round(mean(my_vector)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"\n```\n\n\n:::\n:::\n\n\nWhat do you think this code does? It calculates the mean of `my_vector`, rounds the result to the nearest whole number, and then converts the result to a character. But the code is a bit hard to read because you have to start from the inside of the brackets and work your way out.\n\nInstead, we can use the pipe operator (`%>%`) to chain these functions together in a more readable way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, 2, 3, 4, 5)\nmy_vector %>% mean() %>% round() %>% as.character()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"\n```\n\n\n:::\n:::\n\n\nSee how the code reads naturally from left to right? You can think of the pipe as being like the phrase \"and then\". Here, we're telling R: \"Take `my_vector`, and then calculate the mean, and then round the result, and then convert it to a character.\"\n\nYou'll notice that we didn't need to specify the input to each function. That's because the pipe automatically passes the output of the previous function as the first input to the next function. We can still specify additional arguments to each function if we need to. For example, if we wanted to round the mean to 2 decimal places, we could do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector %>% mean() %>% round(digits = 2) %>% as.character()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3\"\n```\n\n\n:::\n:::\n\n\nR is clever enough to know that the first argument to `round()` is still the output of `mean()`, even though we've now specified the `digits` argument.\n\n::: {.callout-note title=\"Plenty of pipes\"}\nThere is another style of pipe in R, called the 'base R pipe' `|>`, which is available in R version 4.1.0 and later. The base R pipe works in a similar way to the `magrittr` pipe (`%>%`) that we use in this course, but it is not as flexible. We recommend using the `magrittr` pipe for now.\n\nFun fact: the `magrittr` package is named after the [artist René Magritte, who made a famous painting of a pipe](https://en.wikipedia.org/wiki/The_Treachery_of_Images).\n:::\n\nTo type the pipe operator more easily, you can use the keyboard shortcut {{< kbd Cmd-shift-M >}} (although once you get used to it, you might find it easier to type `%>%` manually).\n\n::: {.callout-important title=\"Practice exercises\"}\nTry these practice questions to test your understanding\n\n::: question\n1\\. What is NOT a valid way to re-write the following code using the pipe operator: `round(sqrt(sum(1:10)), 1)`. If you're not sure, try running the different options in the console to see which one gives the same answer.\n\n::: choices\n::: choice\n`1:10 %>% sum() %>% sqrt() %>% round(1)`\n:::\n\n::: {.choice .correct-choice}\n`sum(1:10) %>% sqrt(1) %>% round()`\n:::\n\n::: choice\n`1:10 %>% sum() %>% sqrt() %>% round(digits = 1)`\n:::\n\n::: choice\n`sum(1:10) %>% sqrt() %>% round(digits = 1)`\n:::\n:::\n:::\n\n::: question\n2\\. What is the output of the following code? `letters %>% head() %>% toupper()` Try to guess it before copy-pasting into R.\n\n::: choices\n::: choice\n`\"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"`\n:::\n\n::: choice\n`\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"`\n:::\n\n::: choice\nAn error\n:::\n\n::: {.choice .correct-choice}\n`\"A\" \"B\" \"C\" \"D\" \"E\" \"F\"`\n:::\n:::\n:::\n\n<details>\n\n<summary>Solutions</summary>\n\n<p>\n\n1.  The invalid option is `sum(1:10) %>% sqrt(1) %>% round()`. This is because the `sqrt()` function only takes one argument, so you can't specify `1` as an argument in addition to what is being piped in from `sum(1:10)`. Note that some options used the pipe to send `1:10` to `sum()` (like `1:10 %>% sum()`), and others just used `sum(1:10)` directly. Both are valid ways to use the pipe, it's just a matter of personal preference.\n2.  The output of the code `letters %>% head() %>% toupper()` is `\"A\" \"B\" \"C\" \"D\" \"E\" \"F\"`. The `letters` vector contains the lowercase alphabet, and the `head()` function returns the first 6 elements of the vector. Finally, the `toupper()` function then converts these elements to uppercase.\n\n</p>\n\n</details>\n:::\n\n## Basic data maniuplations {#sec-dataManip}\n\nTo really see the power of the pipe, we will use it together with the `dplyr` package that provides a set of functions to easily filter, sort, select, and summarise data frames. These functions are designed to work well with the pipe, so you can chain them together to create complex data manipulations in a readable format.\n\nFor example, even though we haven't covered the `dplyr` functions yet, you can probably guess what the following code does:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the pipe to chain together our data manipulation steps\nmousezempic_dosage_data %>%\n  filter(cage_number == \"3E\") %>%\n  pull(weight_lost_g) %>%\n  mean()\n```\n:::\n\n\nThis code filters the `mousezempic_dosage_data` data frame to only include data from cage 3E, then pulls out the `weight_lost_g` column, and finally calculates the mean of the values in that column. The first argument to each function is the output of the previous function, and any additional arguments (like the column name in `pull()`) are specified in the brackets (like `round(digits = 2)` from the previous example).\n\nWe also used the enter key after each pipe `%>%` to break up the code into multiple lines to make it easier to read. This isn't required, but is a popular style in the R community, so all the code examples in this session will follow this format.\n\nWe will now introduce some of the most commonly used `dplyr` functions for manipulating data frames. To showcase these, we will use the `mousezempic_dosage_data` that we practiced reading in last session. This imaginary dataset contains information on the weight lost by different strains of mice after being treated with different doses of MouseZempic®.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the data, like we did in session 1\nlibrary(readr)\nmousezempic_dosage_data <- read_delim(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (4): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nBefore we start, let's use what we learned in the previous session to take a look at `mousezempic_dosage_data`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# it's a tibble, so prints nicely\nmousezempic_dosage_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n:::\n\n\nYou might also like to use `View()` to open the data in a separate window and get a closer look.\n\n::: {.callout-note title=\"Using RStudio autocomplete\"}\nAlthough it's great to give our data a descriptive name like `mousezempic_dosage_data`, it can be a bit of a pain to type out every time. Luckily, RStudio has a handy autocomplete feature that can solve this problem. Just start typing the name of the object, and you'll see it will popup:\n\n![RStudio autocomplete](images/S02F01_rstudio_autocomplete.png)\n\nYou can then press {{< kbd Tab >}} to autocomplete it. If there are multiple objects that start with the same letters, you can use the arrow keys to cycle through the options.\n\nTry using autocomplete this session to save yourself some typing!\n:::\n\n### Sorting data {#sec-sorting}\n\nOften, one of the first things you might want to do with a dataset is sort it. In `dplyr`, this is called 'arranging' and is done with the `arrange()` function.\n\n![Arrange orders rows by their values in one or more columns](images/S02F02_arrange.png)\n\nBy default, `arrange()` sorts in ascending order (smallest values first). For example, let's sort the `mousezempic_dosage_data` data frame by the `weight_lost_g` column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data %>%\n  arrange(weight_lost_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 CD-1         3E                   2.85 rep2      female     0.00181\n 3 CD-1         3E                   2.85 rep2      female     0.00184\n 4 CD-1         3E                   2.9  rep2      female     0.00187\n 5 CD-1         2B                   2.9  rep2      female     0.00178\n 6 CD-1         1A                   2.9  rep3      female     0.00188\n 7 BALB C       2B                   2.9  rep1      female     0.00187\n 8 CD-1         3E                   2.92 rep3      female     0.00193\n 9 CD-1         2B                   2.98 rep1      <NA>       0.00179\n10 CD-1         2B                   3    rep1      female     0.00185\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n:::\n\n\nIf we compare this to when we just printed our data above, we can see that the rows are now sorted so that the mice that lost the least weight are at the top.\n\nSometimes you might want to sort in descending order instead (largest values first). You can do this by putting the `desc()` function around your column name, inside `arrange()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data %>%\n  # put desc() around the column name to sort in descending order\n  arrange(desc(weight_lost_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n:::\n\n\nNow we can see the mice that lost the most weight are at the top.\n\n::: {.callout-note title=\"Comments and pipes\"}\nNotice how in the previous example we have written a comment in the middle of the pipe chain. This is a good practice to help you remember what each step is doing, especially when you have a long chain of functions, and won't cause any errors as long as you make sure that the comment is on its own line.\n\nYou can also write comments at the end of the line, just make sure it's after the pipe operator `%>%`.\n\nFor example, these comments are allowed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data %>% # a comment here is fine\n  # a comment here is fine\n  arrange(desc(weight_lost_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n:::\n\n\nBut this will cause an error, because the `#` is before the pipe, so R treats it as part of the comment (notice how the `%>%` has changed colour?) and doesn't know how the two lines relate to each other. It tries to run them separately, which for the first line is ok (it will just print `mousezempic_dosage_data`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmousezempic_dosage_data # this comment will cause an error %>%\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      <NA>      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      <NA>       0.00193\n10 CD-1         1A                   4.25 rep1      <NA>       0.0019 \n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n  arrange(desc(weight_lost_g))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'weight_lost_g' not found\n```\n\n\n:::\n:::\n\n\nBut for the second line, there is an error that R doesn't know what the `weight_lost_g` object is. That's because it's a column in the `mousezempic_dosage_data` data frame, so R only knows what it is in the context of the pipe chain containing that data frame.\n:::\n\nYou can also sort by multiple columns by passing multiple column names to `arrange()`. For example, to sort by the strain first and then by the amount of weight lost:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sort by strain first, then by weight lost\nmousezempic_dosage_data %>%\n  arrange(mouse_strain, weight_lost_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 BALB C       2B                   2.9  rep1      female     0.00187\n 3 BALB C       2B                   3.2  rep2      female     0.00187\n 4 BALB C       2B                   3.25 rep1      female     0.00178\n 5 BALB C       2B                   3.25 rep3      male       0.00187\n 6 BALB C       2B                   3.25 rep3      female     0.00191\n 7 BALB C       2B                   3.3  rep1      male       0.00197\n 8 BALB C       2B                   3.3  rep1      female     0.00195\n 9 BALB C       2B                   3.32 rep3      female     0.00199\n10 BALB C       2B                   3.35 rep2      female     0.00187\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n:::\n\n\nThis will sort the data frame by strain (according to alphabetical order, as it is a character column), and within each strain, they are then sorted by the amount of weight lost.\n\n::: {.callout-note title=\"Piping into View()\"}\nIn the above example, we sorted the data by strain and then by weight lost, but because there are so many mice in each strain, the preview shown in our console doesn't allow us to see the full effect of the sorting.\n\nOne handy trick you can use with pipes is to add `View()` at the end of your chain to open the data in a separate window. Try running this code, and you'll be able to scroll through the full dataset to check that the other mouse strains have also been sorted correctly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sort by strain first, then by weight lost\nmousezempic_dosage_data %>%\n  arrange(mouse_strain, weight_lost_g) %>%\n  View()\n```\n:::\n\n\nThis is a great way to check that your code has actually done what you intended!\n:::\n\n#### Extracting rows with the smallest or largest values {#sec-sliceMinMax}\n\nSlice functions are used to select rows based on their position in the data frame. The `slice_min()` and `slice_max()` functions are particularly useful, because they allow you to select the rows with the smallest or largest values in a particular column.\n\nThis is equivalent to using `arrange()` followed by `head()`, but is more concise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the 10 mice with the lowest drug dose\nmousezempic_dosage_data %>%\n  # slice_min() requires the column to sort by, and n = the number of rows to keep\n  slice_min(drug_dose_g, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   <chr>        <chr>               <dbl> <chr>     <chr>        <dbl>\n 1 CD-1         3E                   3.15 rep1      female     0.00172\n 2 CD-1         3E                   3.4  rep1      female     0.00174\n 3 CD-1         1A                   3.45 rep3      female     0.00176\n 4 CD-1         2B                   3.25 rep1      female     0.00178\n 5 CD-1         2B                   3.9  rep1      male       0.00178\n 6 CD-1         2B                   2.9  rep2      female     0.00178\n 7 BALB C       2B                   3.25 rep1      female     0.00178\n 8 CD-1         2B                   2.98 rep1      <NA>       0.00179\n 9 CD-1         1A                   3.7  rep1      <NA>       0.0018 \n10 CD-1         3E                   3.6  rep1      male       0.0018 \n11 CD-1         3E                   3.8  rep1      male       0.0018 \n12 CD-1         3E                   3.95 rep1      male       0.0018 \n13 CD-1         2B                   3.55 rep1      female     0.0018 \n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n# get the top 5 mice that lost the most weight\nmousezempic_dosage_data %>%\n  # slice_max() has the same arguments as slice_min()\n  slice_max(weight_lost_g, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n6 Black 6      3E                   5.95 rep3      male      0.00229\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n:::\n\n\nBut wait-- neither of those pieces of code actually gave the number of rows we asked for! In the first example, we asked for the 10 mice with the lowest drug dose, but we got 13. And in the second example, we asked for the top 5 mice that lost the most weight, but we got 6. Why aren't the `slice_` functions behaving as expected?\n\nIf we take a look at the help page (type `?slice_min` in the console), we learn that `slice_min()` and `slice_max()` have an argument called `with_ties` that is set to `TRUE` by default. If we want to make sure we only get the number of rows we asked for, we would have to set it to `FALSE`, like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the top 5 mice that lost the most weight\nmousezempic_dosage_data %>%\n  # no ties allowed!\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 8\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  <chr>        <chr>               <dbl> <chr>     <chr>       <dbl>\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n# ℹ 2 more variables: tail_length_mm <dbl>, initial_weight_g <dbl>\n```\n\n\n:::\n:::\n\n\nThis is an important lesson: sometimes functions will behave in a way that is unexpected, and you might need to read their help page or use other guides/google/AI to understand why.\n\n::: {.callout-important title=\"Practice exercises\"}\n\nTry these practice questions to test your understanding\n\n::: question\n1\\. Which code would you use to sort the `mousezempic_dosage_data` data frame from biggest to smallest initial weight?\n\n::: choices\n::: choice\n`mousezempic_dosage_data %>% sort(initial_weight_g)`\n:::\n\n::: choice\n`mousezempic_dosage_data %>% arrange(initial_weight_g)`\n:::\n\n::: choice\n`mousezempic_dosage_data %>% sort(descending(initial_weight_g))`\n:::\n\n::: {.choice .correct-choice}\n`mousezempic_dosage_data %>% arrange(desc(initial_weight_g))`\n:::\n\n:::\n:::\n\n::: question\n2\\. Which code would you use to extract the 3 mice with the highest initial weight from the `mousezempic_dosage_data` data frame?\n\n::: choices\n::: {.choice .correct-choice}\n`mousezempic_dosage_data %>% slice_max(initial_weight_g, n = 3)`\n:::\n\n::: choice\n`mousezempic_dosage_data %>% arrange(desc(initial_weight_g))`\n:::\n\n::: choice\n`mousezempic_dosage_data %>% slice_min(initial_weight_g, n = 3)`\n:::\n\n::: choice\n`mousezempic_dosage_data %>% arrange(initial_weight_g)`\n:::\n:::\n:::\n\n::: question\n3\\. I've written the below code, but one of the comments is messing it up! Which one?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# comment A\nmousezempic_dosage_data # comment B %>%\n  # comment C\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE) # comment D\n```\n:::\n\n\n::: choices\n::: choice\nComment A\n:::\n\n::: {.choice .correct-choice}\nComment B\n:::\n\n::: choice\nComment C\n:::\n\n::: choice\nComment D\n:::\n:::\n:::\n\n<details>\n<summary>Solutions</summary>\n\n1.  The correct code to sort the `mousezempic_dosage_data` data frame from biggest to smallest initial weight is `mousezempic_dosage_data %>% arrange(desc(initial_weight_g))`. The `arrange()` function is used to sort the data frame (although there is a `sort()` function in R, that's not part of dplyr and won't work the same way), and the `desc()` function is used to sort in descending order.\n\n2.  The correct code to extract the 3 mice with the highest initial weight from the `mousezempic_dosage_data` data frame is `mousezempic_dosage_data %>% slice_max(initial_weight_g, n = 3)`. The `slice_max()` function is used to select the rows with the largest values in the `initial_weight_g` column, and the `n = 3` argument specifies that we want to keep 3 rows. The `arrange()` function is not needed in this case, because `slice_max()` will automatically sort the data frame by the specified column.\n\n3.  The comment that is messing up the code is Comment B. The `#` symbol is before the pipe operator `%>%`, so R treats it as part of the comment and this breaks our chain of pipes. The other comments are fine, because they are either at the end of the line or on their own line. Basically, if a comment is changing the colour of the pipe operator (or any other bits of your code), it's in the wrong place!\n</details>\n\n:::\n\n### Filtering data {#sec-filter}\n\nfilteR for rows\n\n### Dealing with missing values {#sec-missing}\n\nhow to find missing values mention that you\n\n### Selecting columns {#sec-select}\n\nseleCt for columns\n\n### Modifying data {#sec-mutate}\n\nwith mutate()\n\n### Summarising data {#sec-summarise}\n\n-   mention that this works with summarize() as well\n\n-   example of calculating mean/median etc\n\n## Grouping {#sec-grouping}\n\n-   teaching grouping with the .by argument in other functions\n\n-   demonstrate the powerful combo of grouping + summarising\n\n## Reshaping and combining data\n\n### Reshaping data with pivot functions {#sec-pivot}\n\n-   brief introduction to pivoting\n\n-   need to think of some kind of meaningful example for this\n\n### Combining data with join functions {#sec-join}\n\n-   left_join() example\n\n## Saving data to a file {#sec-saving}\n\nwrite\\_\\* family of functions\n\n## Summary\n\n### Practice questions",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}